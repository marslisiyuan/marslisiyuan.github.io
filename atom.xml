<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>旅寓安南</title>
  
  <subtitle>My Awesome Site</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://marslisiyuan.github.io/"/>
  <updated>2018-08-01T09:22:30.340Z</updated>
  <id>https://marslisiyuan.github.io/</id>
  
  <author>
    <name>李思源</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>我的个人博客之旅：从jekyll到hexo</title>
    <link href="https://marslisiyuan.github.io/2018/01/10/HEXO/"/>
    <id>https://marslisiyuan.github.io/2018/01/10/HEXO/</id>
    <published>2018-01-09T16:00:00.000Z</published>
    <updated>2018-08-01T09:22:30.340Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><p>[toc]</p><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;喜欢写Blog的人，会经历三个阶段。</p><ul><li>第一阶段，刚接触Blog，觉得很新鲜，试着选择一个免费空间来写。</li><li>第二阶段，发现免费空间限制太多，就自己购买域名和空间，搭建独立博客。</li><li>第三阶段，觉得独立博客的管理太麻烦，最好在保留控制权的前提下，让别人来管，自己只负责写文章。</li></ul><p>引自<a href="http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html" target="_blank" rel="noopener">阮一峰</a></p><p>&emsp;&emsp;第一阶段我已经经历过了，目前在CSDN的文章仍然在更新。但是作为一个免费空间，一个技术博客的聚集地，其管理和运营虽说正在变得越来越好，但是恶心人的事件也时有发生，比如对新手不友好的审核机制、近期改版造成的各种不兼容问题。</p><p>&emsp;&emsp;于是，就想着挣脱枷锁，向第二第三阶段发展。</p><p>&emsp;&emsp;我这人吧凡事都考虑的比较详尽，，我感觉我如果再去经历第二阶段的话既浪费精力又消耗时间，而且自己也过了玩网站、玩博客的年纪，如果申请个域名再搞个网站，我不知道这股热度会持续多久。</p><p>&emsp;&emsp;所以，我就直接跳到了第三个阶段，开始在github上搭建自己的博客。由于自己对前端一无所知，即使使用现成的博客框架，刚开始玩的时候特别费劲。但是经过不断摸索，我的博客已经基本成型，传送门开启：<a href="https://wordzzzz.github.io/" target="_blank" rel="noopener">wordzzzz的个人博客-托管于github</a> <a href="https://wordzzzz.gitee.io/" target="_blank" rel="noopener">wordzzzz的个人博客-托管于gitee</a>。</p><p>&emsp;&emsp;本篇博文并不打算长篇大论的介绍基于GitHub Pages或者Gitee Pages搭建博客的步骤，因为这类的文章实在是太多了，青菜萝卜又各有所爱，不如给出资源，让大家自己折腾。所以我只是在此有序贴出我在搭建博客的过程中用到的各种有用资源，以及搭建博客的大致流程，也算是对我这段时间的一个告别仪式吧。</p><h2 id="GitHub-Pages"><a href="#GitHub-Pages" class="headerlink" title="GitHub Pages"></a>GitHub Pages</h2><p>&emsp;&emsp;我想在GitHub Pages推出之前，由于技术门槛的存在，第三个阶段应该会很少有人涉足。所以在开始一切之前，我们先来看看什么是<a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a>。</p><p>&emsp;&emsp;Github Pages 是面向用户、组织和项目开放的公共静态页面搭建托管服 务，站点可以被免费托管在 Github 上，你可以选择使用 Github Pages 默 认提供的域名 github.io 或者自定义域名来发布站点。Github Pages 支持 自动利用 Jekyll 生成站点，也同样支持纯 HTML 文档，将你的 Jekyll 站 点托管在 Github Pages 上是一个不错的选择。</p><p>&emsp;&emsp;网站首页就是搭建GitHub Pages的过程其中第一步之后，选择不同的git客户端选项，会出现相应的初始化步骤，很人性化。</p><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180110111003603?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br><p></p><p>&emsp;&emsp;大家可以跟着上面的链接先在自己的github新建仓库，仓库名称为username.github.io，其中username要替换成你github的名称，比如我的github名称为wordzzzz，所以我新建的仓库就应该是wordzzzz.github.io。那么等我以后搭建好了我的博客，我就可以通过<a href="https://wordzzzz.github.io来访问我的主页了。" target="_blank" rel="noopener">https://wordzzzz.github.io来访问我的主页了。</a></p><p>&emsp;&emsp;到现在为止，只是搭建博客的准备工作。搭建博客的下一步是选择合适的静态博客框架。</p><h2 id="jekyll-or-hexo"><a href="#jekyll-or-hexo" class="headerlink" title="jekyll or hexo"></a>jekyll or hexo</h2><p>&emsp;&emsp;目前有两大静态博客主流框架：<a href="http://jekyllcn.com/" target="_blank" rel="noopener">jekyll</a>和<a href="https://hexo.io/" target="_blank" rel="noopener">hexo</a>。</p><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180110111311091?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br><p></p><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180110111420247?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br><p></p><p>&emsp;&emsp;我一开始用的是jekyll，这是中文社区翻译出来的<a href="http://jekyllcn.com/" target="_blank" rel="noopener">中文开发文档</a>。我使用的主题是<a href="https://mmistakes.github.io/minimal-mistakes/" target="_blank" rel="noopener">Minimal Mistakes</a>，开发文档很详细。但是后来由于jekyll体验不是很好（中文资料少，我英语比较差我会说嘛），依赖环境总是出问题（需要安装ruby），markdown采用的是Kramdown（Kramdown对我之前的一些博客格式支持的不是很好，我自己写文档用的都是小书匠，然后发表到CSDN，所以并不想花时间在改格式上面），而且我使用的这个主题是个人维护的，种种原因导致最后做出来的博客很难符合我的胃口，最后被我扔进了停尸房<a href="https://github.com/WordZzzz/jekyll_mysite" target="_blank" rel="noopener">jekyll_mysite</a>。</p><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180110111512090?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br><p></p><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180110111533728?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br><p></p><p>&emsp;&emsp;就在我将要放弃之时，hexo拯救了我。对，没错，它有<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">中文开发文档</a>。而在hexo界，使用最多的主题就是<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">next</a>了。光是看到这两份资料，我就已经激动的不行了，这种扁平化设计的网站，不就正是我需要的么。加上详尽的开发文档和丰富的第三方接口，让我对它爱不释手。最终定稿了自己的个人博客，存储在github<a href="https://wordzzzz.github.io/" target="_blank" rel="noopener">wordzzzz的个人博客-托管于github</a>和gitee<a href="https://wordzzzz.gitee.io/" target="_blank" rel="noopener">wordzzzz的个人博客-托管于gitee</a>上。</p><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180110142732584?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br><p></p><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180110142739639?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br><p></p><h2 id="next主题"><a href="#next主题" class="headerlink" title="next主题"></a>next主题</h2><p>&emsp;&emsp;next主题支持三种外观显示，支持多国语言，5套代码高亮主题，可以深度定制。在其<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">Github</a>上，更是有三个主题的代表作，其中我最喜欢的莫过于基于Muse scheme的<a href="https://notes.wanghao.work/" target="_blank" rel="noopener">wanghao的博客</a>。于是，我就在wanghao的博客的基础上进行了相应的更改，形成了我现在的博客，主题文件全部在我的<a href="https://github.com/WordZzzz/hexo-next" target="_blank" rel="noopener">github</a>上，欢迎大家fork、star、follow。</p><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180110114341558?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br><p></p><p>&emsp;&emsp;其实先按照hexo配置开发环境，再按照next文档配置站点文件，完全可以轻松搭建起自己的博客。但是还是藏不住内心那颗年轻的心啊，终究还是搜罗了一些好玩的东西放到了自己的博客上，比如音乐播放器。</p><p>&emsp;&emsp;下面我先简单介绍一下基于github平台、hexo框架的next主题博客开发步骤：</p><ul><li><a href="">Github上新建username.github.io仓库并初始化</a></li><li><a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">PC端安装hexo及其依赖项并熟悉开发流程</a></li><li><a href="https://github.com/WordZzzz/hexo-next" target="_blank" rel="noopener">下载我的主题文件</a>或者<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">下载next主题文件</a></li><li><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">按照next官方教程验证主题</a></li><li><a href="http://theme-next.iissnan.com/theme-settings.html" target="_blank" rel="noopener">按照next官方教程配置站点文件和主题文件</a></li><li><a href="http://theme-next.iissnan.com/third-party-services.html" target="_blank" rel="noopener">按照next官方教程集成第三方服务</a></li><li><a href="https://hexo.io/zh-cn/docs/generating.html" target="_blank" rel="noopener">生成静态文件</a></li><li><a href="https://hexo.io/zh-cn/docs/server.html" target="_blank" rel="noopener">开启本地服务查看站点效果</a></li><li><a href="https://hexo.io/zh-cn/docs/deployment.html" target="_blank" rel="noopener">部署至Github</a></li></ul><p>&emsp;&emsp;文档都非常详细，下面我主要就第三方服务做一些说明。我提到的大部分三方服务在<a href="http://theme-next.iissnan.com/third-party-services.html" target="_blank" rel="noopener">next的官方文档</a>都提及到了，所以具体配置大家跟着官方文档走就行，我只是为每一类服务选择哪个做一下建议。</p><h3 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h3><p>&emsp;&emsp;我用的韩国的<a href="https://livere.com/" target="_blank" rel="noopener">livere</a>，从国内到国外，支持几乎全部社交账号登陆，具体步骤请按照<a href="http://theme-next.iissnan.com/third-party-services.html" target="_blank" rel="noopener">next的官方文档</a>操作。</p><h3 id="数据统计与分析"><a href="#数据统计与分析" class="headerlink" title="数据统计与分析"></a>数据统计与分析</h3><p>&emsp;&emsp;<a href="https://tongji.baidu.com/web/welcome/login" target="_blank" rel="noopener">百度统计</a>和<a href="https://www.google.com/intl/zh-CN/analytics/" target="_blank" rel="noopener">google分析</a>我都加上了，具体步骤请按照<a href="http://theme-next.iissnan.com/third-party-services.html" target="_blank" rel="noopener">next的官方文档</a>操作。</p><h3 id="阅读量统计"><a href="#阅读量统计" class="headerlink" title="阅读量统计"></a>阅读量统计</h3><p>&emsp;&emsp;我用的<a href="https://leancloud.cn/" target="_blank" rel="noopener">LeanCloud</a>，具体操作步骤请直接跳转至<a href="https://notes.wanghao.work/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud" target="_blank" rel="noopener"> 为NexT主题添加文章阅读量统计功能</a>。</p><h3 id="内容分享服务"><a href="#内容分享服务" class="headerlink" title="内容分享服务"></a>内容分享服务</h3><p>&emsp;&emsp;我采用的是<a href="https://github.com/revir/need-more-share2" target="_blank" rel="noopener">need-more-share2</a>，直接在主题配置文件里面打开就行。</p><h3 id="搜索服务"><a href="#搜索服务" class="headerlink" title="搜索服务"></a>搜索服务</h3><p>&emsp;&emsp;我采用的是<a href="https://swiftype.com/" target="_blank" rel="noopener">Swiftype</a>，具体步骤请按照<a href="http://theme-next.iissnan.com/third-party-services.html" target="_blank" rel="noopener">next的官方文档</a>操作。</p><h3 id="网站收录"><a href="#网站收录" class="headerlink" title="网站收录"></a>网站收录</h3><p>&emsp;&emsp;<a href="https://www.google.com/webmasters/tools/" target="_blank" rel="noopener">Google Webmaster tools</a>收录特别快，具体步骤请按照<a href="http://theme-next.iissnan.com/third-party-services.html" target="_blank" rel="noopener">next的官方文档</a>操作。但是<a href="http://ziyuan.baidu.com/?castk=LTE%3D" target="_blank" rel="noopener">百度站长</a>收录的就很慢了，我的到现在还没被收录。</p><h3 id="其他服务"><a href="#其他服务" class="headerlink" title="其他服务"></a>其他服务</h3><p>&emsp;&emsp;NexT 借助于 MathJax 来显示数学公式，此选项默认关闭，如果博客中有公式，那么一定要打开这个选项。</p><h2 id="next进阶"><a href="#next进阶" class="headerlink" title="next进阶"></a>next进阶</h2><p>&emsp;&emsp;最后想说一下其他一些配置，比如添加背景图片、侧边栏头像旋转、侧边栏鼠标滑入显示、背景音乐等等，此处大部分参考<a href="http://mashirosorata.vicp.io/HEXO-NEXT%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE.html" target="_blank" rel="noopener">这个博客</a>。</p><p>&emsp;&emsp;next人性化的为用户提供了custom接口，我们可以在不影响主题文件的基础上进行个性化定制。</p><h3 id="给页面添加背景图片"><a href="#给页面添加背景图片" class="headerlink" title="给页面添加背景图片"></a>给页面添加背景图片</h3><p>&emsp;&emsp;在theme/next/source/css/_custom文件夹下打开custom.styl文件，往里面添加以下代码：</p><figure class="highlight styl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  background: url(/images/blogbk.jpg) no-repeat;</span><br><span class="line">  <span class="comment">/* 背景图垂直、水平均居中 */</span></span><br><span class="line">  <span class="attribute">background-position</span>: center center;</span><br><span class="line">  <span class="comment">/* 当内容高度大于图片高度时，背景图像的位置相对于viewport固定 */</span></span><br><span class="line">  <span class="attribute">background-attachment</span>: fixed;</span><br><span class="line">  <span class="comment">/* 让背景图基于容器大小伸缩 */</span></span><br><span class="line">  <span class="attribute">background-size</span>: cover;</span><br><span class="line">  <span class="comment">/* 设置背景颜色，背景图加载过程中会显示背景色 */</span></span><br><span class="line">  <span class="attribute">background-color</span>: rgba(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其中的css样式属性都可以根据你的自定义图片来更改，以达到最佳的效果。</p><h3 id="给侧边栏添加背景图片"><a href="#给侧边栏添加背景图片" class="headerlink" title="给侧边栏添加背景图片"></a>给侧边栏添加背景图片</h3><p>&emsp;&emsp;在theme/next/source/css/_custom文件夹下打开custom.styl文件，往里面添加以下代码：</p><figure class="highlight styl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#sidebar</span> &#123;</span><br><span class="line">            background:url(/images/sidebar.jpg);</span><br><span class="line">            <span class="attribute">background-size</span>: cover;</span><br><span class="line">            <span class="attribute">background-position</span>:center;</span><br><span class="line">            <span class="attribute">background-repeat</span>:no-repeat;</span><br><span class="line">            <span class="selector-tag">p</span>,<span class="selector-tag">span</span>,<span class="selector-tag">a</span> &#123;<span class="attribute">color</span>: rgba(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">1</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文字背景色以及半透明的设置"><a href="#文字背景色以及半透明的设置" class="headerlink" title="文字背景色以及半透明的设置"></a>文字背景色以及半透明的设置</h3><p>&emsp;&emsp;在theme/next/source/css/_custom文件夹下打开custom.styl文件，往里面添加以下代码：</p><figure class="highlight styl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line">            <span class="attribute">border-radius</span>: <span class="number">20px</span>;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">30px</span> <span class="number">60px</span> <span class="number">30px</span> <span class="number">60px</span>;</span><br><span class="line">            <span class="attribute">background</span>:rgba(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.8</span>) none repeat scroll !important;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其中border-radius是给文章背景设置圆角，margin-top是设置文章到顶部的距离，其中属性可根据自己的需要进行调整。</p><h3 id="评论-来必力-添加背景色"><a href="#评论-来必力-添加背景色" class="headerlink" title="评论(来必力)添加背景色"></a>评论(来必力)添加背景色</h3><p>&emsp;&emsp;在theme/next/source/css/_custom文件夹下打开custom.styl文件，往里面添加以下代码：</p><figure class="highlight styl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#lv-container</span> &#123;</span><br><span class="line">       <span class="attribute">border-radius</span>: <span class="number">20px</span>;</span><br><span class="line">   <span class="attribute">padding</span>: <span class="number">30px</span> <span class="number">60px</span> <span class="number">30px</span> <span class="number">60px</span>;</span><br><span class="line">       <span class="attribute">background</span>:rgba(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.8</span>) none repeat scroll !important;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;和上面一样，背景色和圆角可自己调整更改。</p><h3 id="实现点击出现桃心效果"><a href="#实现点击出现桃心效果" class="headerlink" title="实现点击出现桃心效果"></a>实现点击出现桃心效果</h3><p>&emsp;&emsp;在网址输入如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://7u2ss1.com1.z0.glb.clouddn.com/love.js</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后将里面的代码copy一下，新建love.js文件并且将代码复制进去，然后保存。将love.js文件放到路径/themes/next/source/js/src里面，然后打开\themes\next\layout_layout.swig文件,在末尾（在前面引用会出现找不到的bug）添加以下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 页面点击小红心 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/js/src/love.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="侧边栏头像旋转"><a href="#侧边栏头像旋转" class="headerlink" title="侧边栏头像旋转"></a>侧边栏头像旋转</h3><p>&emsp;&emsp;打开\themes\next\source\css_common\components\sidebar\sidebar-author.styl，在里面添加如下代码：</p><figure class="highlight styl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.site-author-image</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="variable">$site</span>-author-image-padding;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="variable">$site</span>-author-image-width;</span><br><span class="line">  <span class="attribute">height</span>: <span class="variable">$site</span>-author-image-height;</span><br><span class="line">  <span class="attribute">border</span>: <span class="variable">$site</span>-author-image-border-width solid <span class="variable">$site</span>-author-image-border-color;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* start*/</span></span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span></span><br><span class="line">  webkit-<span class="attribute">transition</span>: <span class="number">1.4s</span> all;</span><br><span class="line">  moz-<span class="attribute">transition</span>: <span class="number">1.4s</span> all;</span><br><span class="line">  ms-<span class="attribute">transition</span>: <span class="number">1.4s</span> all;</span><br><span class="line">  <span class="attribute">transition</span>: <span class="number">1.4s</span> all;</span><br><span class="line">  <span class="comment">/* end */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* start */</span></span><br><span class="line"><span class="selector-class">.site-author-image</span>:hover &#123;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#55DAE1</span>;</span><br><span class="line">  webkit-<span class="attribute">transform</span>: rotate(<span class="number">360deg</span>) scale(<span class="number">1.1</span>);</span><br><span class="line">  moz-<span class="attribute">transform</span>: rotate(<span class="number">360deg</span>) scale(<span class="number">1.1</span>);</span><br><span class="line">  ms-<span class="attribute">transform</span>: rotate(<span class="number">360deg</span>) scale(<span class="number">1.1</span>);</span><br><span class="line">  <span class="attribute">transform</span>: rotate(<span class="number">360deg</span>) scale(<span class="number">1.1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* end */</span></span><br></pre></td></tr></table></figure><h3 id="设置鼠标划入侧边栏才显示站点信息："><a href="#设置鼠标划入侧边栏才显示站点信息：" class="headerlink" title="设置鼠标划入侧边栏才显示站点信息："></a>设置鼠标划入侧边栏才显示站点信息：</h3><h4 id="设置自定义div"><a href="#设置自定义div" class="headerlink" title="设置自定义div"></a>设置自定义div</h4><p>&emsp;&emsp;在theme/next/layout/_macro文件夹下打开sidebar.swig文件，找到以下代码行的位置：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">"site-state motion-element"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在其上添加以下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--my custom code begin--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.0/jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/velocity/1.5.0/velocity.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  $("#sidebar").hover(function()&#123;</span></span><br><span class="line"><span class="undefined">    $("#mydivshow").velocity('stop').velocity(&#123;opacity: 1&#125;);</span></span><br><span class="line"><span class="undefined">  &#125;,function()&#123;</span></span><br><span class="line"><span class="undefined">    $("#mydivshow").velocity('stop').velocity(&#123;opacity: 0&#125;);</span></span><br><span class="line"><span class="undefined">  &#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"mydivshow"</span> <span class="attr">class</span>=<span class="string">"mydivshow"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--my custom code end--&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后找到代码行：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">&#123;% if display_toc and toc(page.content).length &gt; 1 %&#125;</span><br><span class="line"><span class="comment">&lt;!--noindex--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"post-toc-wrap motion-element sidebar-panel sidebar-panel-active"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在此的上方添加一个，如下所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--my custom code begin--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--my custom code end--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">&#123;% if display_toc and toc(page.content).length &gt; 1 %&#125;</span><br><span class="line"><span class="comment">&lt;!--noindex--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"post-toc-wrap motion-element sidebar-panel sidebar-panel-active"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"post-toc"</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="自定义区域的初始化设置"><a href="#自定义区域的初始化设置" class="headerlink" title="自定义区域的初始化设置"></a>自定义区域的初始化设置</h4><p>&emsp;&emsp;在theme/next/source/css/_custom文件夹下打开custom.styl文件，向里面增添下列代码：</p><figure class="highlight styl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#mydivshow&#123;<span class="attribute">opacity</span>: <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure><p>注：具体代码添加位置以及代码里的section.site-overview可以自己修改，<div id="mydivshow" class="mydivshow">和末尾的</div>是控制显示区域，section.site-overview则是用户鼠标滑入划出时的触发事件区域。</p><h3 id="自定义音乐播放器"><a href="#自定义音乐播放器" class="headerlink" title="自定义音乐播放器"></a>自定义音乐播放器</h3><p>&emsp;&emsp;描述：本站所用的音乐播放器是由DIYgod所制作的APlayer，其详细资料可参见<a href="https://aplayer.js.org/docs/#/" target="_blank" rel="noopener">这里</a>。</p><h4 id="安装APlayer插件"><a href="#安装APlayer插件" class="headerlink" title="安装APlayer插件"></a>安装APlayer插件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install aplayer --save</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;安装完后在node_modules目录下找到APlayer.min.js文件，将其复制到theme/next/source/js/src/目录下。</p><h4 id="生成音乐播放器"><a href="#生成音乐播放器" class="headerlink" title="生成音乐播放器"></a>生成音乐播放器</h4><p>&emsp;&emsp;在你想要加入音乐播放器的地方插入以下代码，本站把他放在了侧边栏里，具体操作如下。</p><p>&emsp;&emsp;打开theme/next/layout/_custom/文件夹下的sidebar.swig文件，向其中添加以下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"player1"</span> <span class="attr">class</span>=<span class="string">"aplayer"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/js/src/APlayer.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">var ap = new APlayer(&#123;</span></span><br><span class="line"><span class="undefined">    element: document.getElementById('player1'),                       // Optional, player element</span></span><br><span class="line"><span class="undefined">    narrow: false,                                                     // Optional, narrow style</span></span><br><span class="line"><span class="undefined">    autoplay: false,                                                    // Optional, autoplay song(s), not supported by mobile browsers</span></span><br><span class="line"><span class="undefined">    showlrc: 0,                                                        // Optional, show lrc, can be 0, 1, 2, see: ###With lrc</span></span><br><span class="line"><span class="undefined">    mutex: true,                                                       // Optional, pause other players when this player playing</span></span><br><span class="line"><span class="undefined">    theme: '#e6d0b2',                                                  // Optional, theme color, default: #b7daff</span></span><br><span class="line"><span class="undefined">    mode: 'random',                                                    // Optional, play mode, can be `random` `single` `circulation`(loop) `order`(no loop), default: `circulation`</span></span><br><span class="line"><span class="undefined">    preload: 'metadata',                                               // Optional, the way to load music, can be 'none' 'metadata' 'auto', default: 'auto'</span></span><br><span class="line"><span class="undefined">    listmaxheight: '513px',                                             // Optional, max height of play list</span></span><br><span class="line"><span class="undefined">    music: &#123;                                                           // Required, music info, see: ###With playlist</span></span><br><span class="line"><span class="undefined">        title: '你曾是少年',                                          // Required, music title</span></span><br><span class="line"><span class="undefined">        author: 'cover',                                              // Required, music author</span></span><br><span class="line"><span class="undefined">        url: 'http://mp3.qqmusic.cc/yq/102426570.mp3',                // Required, music url</span></span><br><span class="line"><span class="undefined">        pic: '/images/visitor.jpg',                                   // Optional, music picture</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">&#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里的歌曲url必须是在线音乐，当时现在大部分播放器都不会曝露出真实的歌曲播放地址，找资源很是费劲。这里给大家推荐一个<a href="http://www.qqmusic.cc/" target="_blank" rel="noopener">解析平台</a>，大部分的qq音乐还是可以解析出来或者直接在该平台上找到播放链接的。大家可以写多个music结构，以此来添加多个音乐。</p><p>&emsp;&emsp;当然，我们还可以通过添加网易云音乐外链的方式在我们的博客中添加音乐。打开theme/next/layout/_custom/文件夹下的sidebar.swig文件，向其中添加以下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"music163player"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">frameborder</span>=<span class="string">"no"</span> <span class="attr">border</span>=<span class="string">"0"</span> <span class="attr">marginwidth</span>=<span class="string">"0"</span> <span class="attr">marginheight</span>=<span class="string">"0"</span> <span class="attr">width</span>=<span class="string">330</span> <span class="attr">height</span>=<span class="string">86</span> <span class="attr">src</span>=<span class="string">"//music.163.com/outchain/player?type=2&amp;id=458789090&amp;auto=0&amp;height=66"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;替换上述代码中的iframe标签之间的内容，就可以替换不同的音乐进行播放了。网易云音乐的歌单也可以生成外链，前提是歌单里的歌曲都有版权哦~</p><h4 id="自定义播放器样式"><a href="#自定义播放器样式" class="headerlink" title="自定义播放器样式"></a>自定义播放器样式</h4><p>&emsp;&emsp;包含颜色更改，列表歌曲信息的排版修改。</p><p>&emsp;&emsp;在theme/next/source/css/_custom文件夹下打开custom.styl文件，往里面添加以下代码：</p><figure class="highlight styl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.aplayer-list</span> <span class="selector-tag">ol</span> <span class="selector-tag">li</span>:hover &#123;   <span class="comment">/*列表悬停颜色*/</span></span><br><span class="line">                  <span class="attribute">background</span>:rgba(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">1</span>) none repeat scroll !important;&#125;</span><br><span class="line"><span class="selector-class">.aplayer-list</span> <span class="selector-tag">ol</span> <span class="selector-tag">li</span> &#123;   <span class="comment">/*列表底色*/</span></span><br><span class="line">                        <span class="attribute">background</span>:rgba(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">1</span>);&#125;</span><br><span class="line"><span class="selector-class">.aplayer-list-light</span> &#123;   <span class="comment">/*列表播放歌曲颜色*/</span></span><br><span class="line">                      <span class="attribute">background</span>:rgba(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">1</span>) none repeat scroll !important;&#125;</span><br><span class="line"><span class="selector-id">#player1</span> &#123;    <span class="comment">/*边框样式*/</span></span><br><span class="line">          <span class="attribute">border-radius</span>: <span class="number">6px</span>;</span><br><span class="line">          <span class="selector-tag">div</span>,<span class="selector-tag">ol</span> &#123;<span class="attribute">border-radius</span>: <span class="number">6px</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="selector-id">#player1</span> *&#123;<span class="attribute">color</span>: rgba(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">1</span>);&#125;    <span class="comment">/*字体颜色*/</span></span><br><span class="line"><span class="comment">/*列表歌曲信息的排版*/</span></span><br><span class="line">.aplayer-list-index&#123;<span class="attribute">float</span>:left;&#125;</span><br><span class="line">.aplayer-list-title&#123;<span class="attribute">float</span>:left;&#125;</span><br><span class="line">.aplayer-list-author&#123;<span class="attribute">float</span>:right;&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义萌萌哒音乐播放控制边栏"><a href="#自定义萌萌哒音乐播放控制边栏" class="headerlink" title="自定义萌萌哒音乐播放控制边栏"></a>自定义萌萌哒音乐播放控制边栏</h3><p>&emsp;&emsp;这一步要在自定义音乐播放器的配置完成之后才能进行，因为aplayer-controler依赖于aplayer来实现播放功能。</p><h4 id="安装aplayer-controler插件"><a href="#安装aplayer-controler插件" class="headerlink" title="安装aplayer-controler插件"></a>安装aplayer-controler插件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install aplayer-controler --save</span><br></pre></td></tr></table></figure><h4 id="添加js代码"><a href="#添加js代码" class="headerlink" title="添加js代码"></a>添加js代码</h4><p>&emsp;&emsp;安装APlayer-Controler的js文件：<a href="https://github.com/Mashiro-Sorata/APlayer-Controler/blob/master/demo/src/Aplayer-Controler.js" target="_blank" rel="noopener">APlayer-Controler.js</a></p><p>&emsp;&emsp;将其放入theme/next/source/js/src下。</p><h4 id="创建按钮区域"><a href="#创建按钮区域" class="headerlink" title="创建按钮区域"></a>创建按钮区域</h4><p>&emsp;&emsp;在theme/next/layout/_custom/文件夹下新建一个myapcontroler.swig的文件。向其中添加以下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/js/src/Aplayer-Controler.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"AP-controler"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">var myapc=new APlayer_Controler(&#123;</span></span><br><span class="line"><span class="undefined">APC_dom:$('#AP-controler'),</span></span><br><span class="line"><span class="undefined">aplayer:ap, //此为绑定的aplayer对象</span></span><br><span class="line"><span class="undefined">attach_right:true,</span></span><br><span class="line"><span class="undefined">position:&#123;top:'300px',bottom:''&#125;,</span></span><br><span class="line"><span class="undefined">fixed:true,</span></span><br><span class="line"><span class="undefined">btn_width:100,</span></span><br><span class="line"><span class="undefined">btn_height:120,</span></span><br><span class="line"><span class="undefined">img_src:['http://oty1v077k.bkt.clouddn.com/bukagirl.jpg',</span></span><br><span class="line"><span class="undefined">'http://oty1v077k.bkt.clouddn.com/jumpgirl.jpg',</span></span><br><span class="line"><span class="undefined">'http://oty1v077k.bkt.clouddn.com/pentigirl.jpg',</span></span><br><span class="line"><span class="undefined">'http://oty1v077k.bkt.clouddn.com/%E8%90%8C1.gif'],</span></span><br><span class="line"><span class="undefined">img_style:&#123;repeat:'no-repeat',position:'center',size:'contain'&#125;,</span></span><br><span class="line"><span class="undefined">ctrls_color:'rgba(173,255,47,0.8)',</span></span><br><span class="line"><span class="undefined">ctrls_hover_color:'rgba(255,140,0,0.7)',</span></span><br><span class="line"><span class="undefined">tips_on:true,</span></span><br><span class="line"><span class="undefined">tips_width:140,</span></span><br><span class="line"><span class="undefined">tips_height:25,</span></span><br><span class="line"><span class="undefined">tips_color:'rgba(255,255,255,0.6)',</span></span><br><span class="line"><span class="undefined">tips_content:&#123;&#125;,</span></span><br><span class="line"><span class="undefined">timeout:30</span></span><br><span class="line"><span class="undefined">&#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="将控制按钮加入body页面"><a href="#将控制按钮加入body页面" class="headerlink" title="将控制按钮加入body页面"></a>将控制按钮加入body页面</h4><p>&emsp;&emsp;在theme/next/layout文件夹下打开_layout.swig文件，在前添加以下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% include '_custom/myapcontroler.swig' %&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;到此，自定义音乐播放控制边栏就基本完成，完成整个配置需要根据自己的主题背景进一步修改完善。</p><hr><p><strong><font color="red" size="3" face="仿宋">本教程到此结束，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;p&gt;[toc]&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;
      
    
    </summary>
    
      <category term="博客搭建" scheme="https://marslisiyuan.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="jekyll" scheme="https://marslisiyuan.github.io/tags/jekyll/"/>
    
      <category term="hexo" scheme="https://marslisiyuan.github.io/tags/hexo/"/>
    
      <category term="github" scheme="https://marslisiyuan.github.io/tags/github/"/>
    
      <category term="gitee" scheme="https://marslisiyuan.github.io/tags/gitee/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法系列之一：八大排序综述</title>
    <link href="https://marslisiyuan.github.io/2018/01/09/DS/"/>
    <id>https://marslisiyuan.github.io/2018/01/09/DS/</id>
    <published>2018-01-08T16:00:00.000Z</published>
    <updated>2018-08-01T09:22:30.340Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>个人博客：<a href="https://wordzzzz.github.io/" target="_blank" rel="noopener">https://wordzzzz.github.io/</a> <a href="https://wordzzzz.gitee.io/" target="_blank" rel="noopener">https://wordzzzz.gitee.io/</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/DS&amp;A/sort" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/DS&amp;A/sort</a></strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>[toc]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;剑指offer刷完了，是时候总结一波数据结构与算法了。本系列文章暂定包括数据结构中树和图的各种操作，以及查找、排序等基本算法和动态规划等高级算法。本系列文章只是作为总结性的文献，为自己日后的面试做准备。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;直接引自维基百科：<a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">排序算法</a>。总结性强。</p><p>&emsp;&emsp;在计算机科学与数学中，一个排序算法（英语：Sorting algorithm）是一种能将一串数据依照特定排序方式进行排列的一种算法。最常用到的排序方式是数值顺序以及字典顺序。有效的排序算法在一些算法（例如搜索算法与合并算法）中是重要的，如此这些算法才能得到正确解答。排序算法也用在处理文字数据以及产生人类可读的输出结果。基本上，排序算法的输出必须遵守下列两个原则：</p><ul><li>输出结果为递增序列（递增是针对所需的排序顺序而言）</li><li>输出结果是原输入的一种排列、或是重组</li></ul><p>&emsp;&emsp;虽然排序算法是一个简单的问题，但是从计算机科学发展以来，在此问题上已经有大量的研究。举例而言，冒泡排序在1956年就已经被研究。虽然大部分人认为这是一个已经被解决的问题，有用的新算法仍在不断的被发明。（例子：图书馆排序在2004年被发表）</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>&emsp;&emsp;在计算机科学所使用的排序算法通常被分类为：</p><ul><li>计算的时间复杂度（最差、平均、和最好性能），依据列表（list）的大小(n)。一般而言，好的性能是O(n log n)，坏的性能是O(n2)。对于一个排序理想的性能是O(n)，但平均而言不可能达到。基于比较的排序算法对大多数输入而言至少需要O(n log n)。</li><li>内存使用量（以及其他电脑资源的使用）</li><li>稳定性：稳定排序算法会让原本有相等键值的纪录维持相对次序。也就是如果一个排序算法是稳定的，当有两个相等键值的纪录R和S，且在原本的列表中R出现在S之前，在排序过的列表中R也将会是在S之前。</li><li>依据排序的方法：插入、交换、选择、合并等等。</li></ul><h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><p>&emsp;&emsp;当相等的元素是无法分辨的，比如像是整数，稳定性并不是一个问题。然而，假设以下的数对将要以他们的第一个数字来排序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(4, 1)  (3, 1)  (3, 7)（5, 6）</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这个状况下，有可能产生两种不同的结果，一个是让相等键值的纪录维持相对的次序，而另外一个则没有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(3, 1)  (3, 7)  (4, 1)  (5, 6)  （维持次序）</span><br><span class="line">(3, 7)  (3, 1)  (4, 1)  (5, 6)  （次序被改变）</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;不稳定排序算法可能会在相等的键值中改变纪录的相对次序，但是稳定排序算法从来不会如此。不稳定排序算法可以被特别地实现为稳定。实现的一个方式是人工扩充键值的比较（比如上面的比较中加入第二个标准：第二个键值的大小），从而在键值相同的两个对象之间进行比较时，使用在原先数据次序中的条目。然而，要记录这种次序通常牵涉到额外的空间负担。</p><h3 id="排序算法列表"><a href="#排序算法列表" class="headerlink" title="排序算法列表"></a>排序算法列表</h3><p>&emsp;&emsp;在这个表格中，n是要被排序的纪录数量以及k是不同键值的数量。</p><h4 id="稳定的排序"><a href="#稳定的排序" class="headerlink" title="稳定的排序"></a>稳定的排序</h4><ul><li>冒泡排序（bubble sort）— O(n2)</li><li>插入排序（insertion sort）— O(n2)</li><li>鸡尾酒排序（cocktail sort）— O(n2)</li><li>桶排序（bucket sort）— O(n)；需要O(k)额外空间</li><li>计数排序（counting sort）— O(n+k)；需要O(n+k)额外空间</li><li>归并排序（merge sort）— O(n log n)；需要O(n)额外空间</li><li>原地归并排序 — O(n log2 n)如果使用最佳的现在版本</li><li>二叉排序树排序（binary tree sort）— O(n log n)期望时间；O(n2)最坏时间；需要O(n)额外空间</li><li>鸽巢排序（pigeonhole sort）— O(n+k)；需要O(k)额外空间</li><li>基数排序（radix sort）— O(n·k)；需要O(n)额外空间</li><li>侏儒排序（gnome sort）— O(n2)</li><li>图书馆排序（library sort）— O(n log n)期望时间；O(n2)最坏时间；需要(1+ε)n额外空间</li><li>块排序（block sort）— O(n log n)</li></ul><h4 id="不稳定的排序"><a href="#不稳定的排序" class="headerlink" title="不稳定的排序"></a>不稳定的排序</h4><ul><li>选择排序（selection sort）— O(n2)</li><li>希尔排序（shell sort）— O(n log2 n)如果使用最佳的现在版本</li><li>Clover排序算法（Clover sort）— O(n)期望时间，O(n2)最坏情况</li><li>梳排序 — O(n log n)</li><li>堆排序（heap sort）— O(n log n)</li><li>平滑排序（smooth sort）— O(n log n)</li><li>快速排序（quick sort）— O(n log n)期望时间，O(n2)最坏情况；对于大的、随机数列表一般相信是最快的已知排序</li><li>内省排序（introsort）—O (n log n)</li><li>耐心排序（patience sort）— O(n log n + k)最坏情况时间，需要额外的O(n + k)空间，也需要找到最长的递增子序列（longest increasing subsequence）</li></ul><h4 id="不实用的排序"><a href="#不实用的排序" class="headerlink" title="不实用的排序"></a>不实用的排序</h4><ul><li>Bogo排序 — O(n × n!)，最坏的情况下期望时间为无穷</li><li>Stupid排序 — O(n3);递归版本需要O(n2)额外内存</li><li>珠排序（bead sort）— O(n) or O(√n),但需要特别的硬件</li><li>煎饼排序 — O(n),但需要特别的硬件</li><li>臭皮匠排序（stooge sort）算法简单，但需要约n^2.7的时间</li></ul><hr><p>==概述到此结束，下面分八篇文章依次对典型的八种排序进行图文并茂的讲解和c++实现。==</p><hr><p>&emsp;&emsp;先贴一下八大排序的性能概括图：</p><p>&emsp;&emsp;再贴出来以后要用到的main函数和头文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> len = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(*arr);</span><br><span class="line"><span class="comment">//double arr[] = &#123;4.5, 2.3,6.7, 3.5, 1.1&#125;;</span></span><br><span class="line"><span class="comment">//const int len = sizeof(arr) / sizeof(arr[0]);</span></span><br><span class="line"><span class="comment">//BubbleSort(arr, len);</span></span><br><span class="line"><span class="comment">//BubbleSort1(arr, len);</span></span><br><span class="line"><span class="comment">//BubbleSort2(arr, len);</span></span><br><span class="line"><span class="comment">//BubbleSort3(arr, len);</span></span><br><span class="line"><span class="comment">//InsertSort(arr, len);</span></span><br><span class="line"><span class="comment">//ShellSort(arr, len);</span></span><br><span class="line"><span class="comment">//QuickSort(arr, len);</span></span><br><span class="line"><span class="comment">//QuickSortIteration(arr, len);</span></span><br><span class="line"><span class="comment">//SelectSort(arr, len);</span></span><br><span class="line"><span class="comment">//HeapSort(arr, len);</span></span><br><span class="line"><span class="comment">//MergeSort(arr, len); </span></span><br><span class="line">MergeSortIteration(arr, len);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> v : arr)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125; <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最后就要打开传送门了：</p><p>csdn告诉我今天上传博客的次数到达上限了，然而我还有两个没有上传，那我只好先引流到我的个人博客了。</p><ul><li><a href="https://wordzzzz.github.io/2018/01/01/DS/" target="_blank" rel="noopener">插入排序</a>：（有序区，无序区）。把无序区的第一个元素插入到有序区的合适的位置。对数组：比较得少，换得多。</li><li><a href="https://wordzzzz.github.io/2018/01/02/DS/" target="_blank" rel="noopener">希尔排序</a>：每一轮按照事先决定的间隔进行插入排序，间隔会依次缩小，最后一次一定要是1。</li><li><a href="https://wordzzzz.github.io/2018/01/03/DS/" target="_blank" rel="noopener">选择排序</a>：（有序区，无序区）。在无序区里找一个最小的元素跟在有序区的后面。对数组：比较得多，换得少。</li><li><a href="https://wordzzzz.github.io/2018/01/04/DS/" target="_blank" rel="noopener">堆排序</a>：（最大堆，有序区）。<br>从堆顶把根卸出来放在有序区之前，再恢复堆。</li><li><a href="https://wordzzzz.github.io/2018/01/05/DS/" target="_blank" rel="noopener">冒泡排序</a>：（无序区，有序区）。从无序区通过交换找出最大元素放到有序区前端。</li><li><a href="https://wordzzzz.github.io/2018/01/06/DS/" target="_blank" rel="noopener">快速排序</a>：（小数，基准元素，大数）。<br>在区间中随机挑选一个元素作基准，将小于基准的元素放在基准之前，大于基准的元素放在基准之后，再分别对小数区与大数区进行排序。</li><li><a href="https://wordzzzz.github.io/2018/01/07/DS/" target="_blank" rel="noopener">归并排序</a>：把数据分为两段，从两段中逐个选最小的元素移入新数据段的末尾。<br>可从上到下或从下到上进行。</li><li><a href="https://wordzzzz.github.io/2018/01/08/DS/" target="_blank" rel="noopener">基数排序</a>：一种多关键字的排序算法，可用桶排序实现。</li></ul><p>参考链接：<br><a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">维基百科</a><br><a href="https://visualgo.net/en/sorting" target="_blank" rel="noopener">数据结构与算法可视化可视化</a><br><a href="http://www.cnblogs.com/skywang12345/category/508186.html" target="_blank" rel="noopener">数据结构与算法</a><br><a href="http://www.open-open.com/lib/view/open1404781467544.html" target="_blank" rel="noopener">排序算法可视化</a><br><a href="http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/" target="_blank" rel="noopener">经典排序算法总结与实现</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://marslisiyuan.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="https://marslisiyuan.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法系列之一：八大排序之基数排序</title>
    <link href="https://marslisiyuan.github.io/2018/01/08/DS/"/>
    <id>https://marslisiyuan.github.io/2018/01/08/DS/</id>
    <published>2018-01-07T16:00:00.000Z</published>
    <updated>2018-08-01T09:22:30.339Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>个人博客：<a href="https://wordzzzz.github.io/" target="_blank" rel="noopener">https://wordzzzz.github.io/</a> &amp;&amp; <a href="https://wordzzzz.gitee.io/" target="_blank" rel="noopener">https://wordzzzz.gitee.io/</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/DS-A" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/DS-A</a></strong></li><li><strong>博客作者：WordZzzz，一只热爱技术的文艺青年</strong></li></ul><hr><p>[toc]</p><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;建议先看排序综述，传送门：<a href="http://blog.csdn.net/u011475210/article/details/79014021" target="_blank" rel="noopener">数据结构与算法系列之一：八大排序综述</a>。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>&emsp;&emsp;基数排序（英语：Radix sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。基数排序的发明可以追溯到1887年赫尔曼·何乐礼在打孔卡片制表机（Tabulation Machine）上的贡献。</p><p>&emsp;&emsp;基数排序法会使用到桶 (Bucket)，顾名思义，通过将要比较的位（个位、十位、百位…），将要排序的元素分配至 0~9 个桶中，借以达到排序的作用，在某些时候，基数排序法的效率高于其它的比较性排序法。</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>&emsp;&emsp;它是这样实现的：</p><ul><li>将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。</li><li>然后，从最低位开始，依次进行一次排序。</li><li>这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。</li></ul><p>&emsp;&emsp;基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。</p><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>&emsp;&emsp;wordzzzz的小数据规模演示：</p><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180109153959062?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="radixsort from wordzzzz"></div><br><p></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 获取数组a中最大值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_max</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, max;</span><br><span class="line"></span><br><span class="line">max = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; length; i++)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[i] &gt; max)</span><br><span class="line">max = <span class="built_in">array</span>[i];</span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 对数组按照"某个位数"进行排序(桶排序)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">count_sort</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length, <span class="keyword">int</span> <span class="built_in">exp</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T* output = (T*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(T) * length);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (output == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fputs</span>(<span class="string">"Error: out of memory\n"</span>, <span class="built_in">stderr</span>);</span><br><span class="line"><span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> i, buckets[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++)<span class="comment">// 将数据出现的次数存储在buckets[]中</span></span><br><span class="line">buckets[(<span class="built_in">array</span>[i] / <span class="built_in">exp</span>) % <span class="number">10</span>]++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)<span class="comment">// 更改buckets[i]。目的是让更改后的buckets[i]的值，是该数据在output[]中的位置。</span></span><br><span class="line">buckets[i] += buckets[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)<span class="comment">// 将数据存储到临时数组output[]中，这里的对应关系一定要捋清楚</span></span><br><span class="line">output[--buckets[(<span class="built_in">array</span>[i] / <span class="built_in">exp</span>) % <span class="number">10</span>]] = <span class="built_in">array</span>[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++)<span class="comment">// 将排序好的数据赋值给array[]</span></span><br><span class="line"><span class="built_in">array</span>[i] = output[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 基数排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RadixSort</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">exp</span>;<span class="comment">// 指数。当对数组按各位进行排序时，exp=1；按十位进行排序时，exp=10；...</span></span><br><span class="line"><span class="keyword">int</span> max = get_max(<span class="built_in">array</span>, length);<span class="comment">// 数组array中的最大值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">exp</span> = <span class="number">1</span>; max / <span class="built_in">exp</span> &gt; <span class="number">0</span>; <span class="built_in">exp</span> *= <span class="number">10</span>)<span class="comment">// 从个位开始，对数组array按"指数"进行排序</span></span><br><span class="line">count_sort(<span class="built_in">array</span>, length, <span class="built_in">exp</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><ul><li>数据结构    数组</li><li>平均时间复杂度 $O(d*(n+r))$</li><li>最好情况 $O(d*(n+r))$</li><li>最坏情况 $O(d*(n+r))$</li><li>空间复杂度 $O(n+r)$</li></ul><p>&emsp;&emsp;其中，d 为位数，r 为基数，n 为原数组个数。在基数排序中，因为没有比较操作，所以在复杂上，最好的情况与最坏的情况在时间上是一致的，均为 O(d*(n + r))。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>&emsp;&emsp;如果捋不清上述代码中的数组对应关系，可以参考一下下面这两张图的讲解，来源：<a href="http://www.cnblogs.com/skywang12345/p/3603669.html。" target="_blank" rel="noopener">http://www.cnblogs.com/skywang12345/p/3603669.html。</a></p><ul><li>个位的数值范围是[0,10)。因此，参见桶数组buckets[]，将数组按照个位数值添加到桶中。</li></ul><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180109154616722?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="step1"></div><br><p></p><ul><li>接着是根据桶数组buckets[]来进行排序。假设将排序后的数组存在output[]中；找出output[]和buckets[]之间的联系就可以对数据进行排序了。</li></ul><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180109154657318?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="step2"></div><br><p></p><p>&emsp;&emsp;基数排序不改变相同元素之间的相对顺序，因此它是稳定的排序算法。</p><p>&emsp;&emsp;基数排序 vs 计数排序 vs 桶排序</p><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><ul><li>基数排序：根据键值的每位数字来分配桶</li><li>计数排序：每个桶只存储单一键值</li><li>桶排序：每个桶存储一定范围的数值</li></ul><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://marslisiyuan.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="https://marslisiyuan.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="基数排序" scheme="https://marslisiyuan.github.io/tags/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法系列之一：八大排序之归并排序</title>
    <link href="https://marslisiyuan.github.io/2018/01/07/DS/"/>
    <id>https://marslisiyuan.github.io/2018/01/07/DS/</id>
    <published>2018-01-06T16:00:00.000Z</published>
    <updated>2018-08-01T09:22:30.339Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>个人博客：<a href="https://wordzzzz.github.io/" target="_blank" rel="noopener">https://wordzzzz.github.io/</a> &amp;&amp; <a href="https://wordzzzz.gitee.io/" target="_blank" rel="noopener">https://wordzzzz.gitee.io/</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/DS-A" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/DS-A</a></strong></li><li><strong>博客作者：WordZzzz，一只热爱技术的文艺青年</strong></li></ul><hr><p>[toc]</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;建议先看排序综述，传送门：<a href="http://blog.csdn.net/u011475210/article/details/79014021" target="_blank" rel="noopener">数据结构与算法系列之一：八大排序综述</a>。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>&emsp;&emsp;归并排序（英语：Merge sort，或mergesort），是创建在归并操作上的一种有效的排序算法，效率为 ${\displaystyle O(n\log n)}$ 。1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>&emsp;&emsp;归并操作（merge），也叫归并算法，指的是将两个已经排序的序列合并成一个序列的操作。归并排序算法依赖归并操作。</p><p>递归法（Bottom-up）<br>原理如下（假设序列共有 ${\displaystyle n}$ 个元素）：</p><ul><li>将序列每相邻两个数字进行归并操作，形成 ${\displaystyle ceil(n/2)}$ 个序列，排序后每个序列包含两/一个元素。</li><li>若此时序列数不是1个则将上述序列再次归并，形成 ${\displaystyle ceil(n/4)}$个序列，每个序列包含四/三个元素。</li><li>重复步骤2，直到所有元素排序完毕，即序列数为1。</li></ul><p>迭代法（Top-down）</p><ul><li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列。</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置。</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置。</li><li>重复步骤3直到某一指针到达序列尾。</li><li>将另一序列剩下的所有元素直接复制到合并序列尾。</li></ul><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>&emsp;&emsp;wikipedia的大数据规模演示：</p><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180109111825567?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="merge from wikipedia"></div><br><p></p><p>&emsp;&emsp;wordzzzz的小数据规模演示：</p><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180109111851701?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="bubblesort from wordzzzz"></div><br><p></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="递归版"><a href="#递归版" class="headerlink" title="递归版"></a>递归版</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 归并排序递归版</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(T *<span class="built_in">array</span>, T *reg, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> left1 = left, right1 = mid;</span><br><span class="line"><span class="keyword">int</span> left2 = mid + <span class="number">1</span>, right2 = right;</span><br><span class="line"><span class="keyword">int</span> k = left;</span><br><span class="line"><span class="keyword">while</span> (left1 &lt;= right1 &amp;&amp; left2 &lt;= right2)</span><br><span class="line">reg[k++] = <span class="built_in">array</span>[left1] &lt; <span class="built_in">array</span>[left2] ? <span class="built_in">array</span>[left1++] : <span class="built_in">array</span>[left2++];</span><br><span class="line"><span class="keyword">while</span> (left1 &lt;= right1)</span><br><span class="line">reg[k++] = <span class="built_in">array</span>[left1++];</span><br><span class="line"><span class="keyword">while</span> (left2 &lt;= right2)</span><br><span class="line">reg[k++] = <span class="built_in">array</span>[left2++];</span><br><span class="line"><span class="keyword">for</span> (k = left; k &lt;= right; k++)</span><br><span class="line"><span class="built_in">array</span>[k] = reg[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSortRecursive</span><span class="params">(T *<span class="built_in">array</span>, T *reg, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &gt;= right)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">MergeSortRecursive(<span class="built_in">array</span>, reg, left, mid);<span class="comment">//左序列排序</span></span><br><span class="line">MergeSortRecursive(<span class="built_in">array</span>, reg, mid + <span class="number">1</span>, right);<span class="comment">//右序列排序</span></span><br><span class="line">Merge(<span class="built_in">array</span>, reg, left, mid, right);<span class="comment">//合并左右序列</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span> </span>&#123; </span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">throw</span> invalid_argument(<span class="string">"Array must not be empty"</span>); </span><br><span class="line"><span class="keyword">if</span> (length &lt;= <span class="number">0</span>) </span><br><span class="line"><span class="keyword">return</span>; </span><br><span class="line">T* reg = (T*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(T) * length);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (reg == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fputs</span>(<span class="string">"Error: out of memory\n"</span>, <span class="built_in">stderr</span>);</span><br><span class="line"><span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line">MergeSortRecursive(<span class="built_in">array</span>, reg, <span class="number">0</span>, length - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">delete</span>[] reg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="迭代版"><a href="#迭代版" class="headerlink" title="迭代版"></a>迭代版</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 归并排序迭代版</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSortIteration</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">throw</span> invalid_argument(<span class="string">"Array must not be empty"</span>);</span><br><span class="line"><span class="keyword">if</span> (length &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">T* regB = (T*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(T) * length);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (regB == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">"Error: out of memory\n"</span>, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> seg = <span class="number">1</span>; seg &lt; length; seg += seg) &#123;<span class="comment">//步长，每次翻倍</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> left = <span class="number">0</span>; left &lt; length; left += seg + seg) &#123;</span><br><span class="line"><span class="keyword">int</span> low = left, mid = min(left + seg, length), high = min(left + seg + seg, length);<span class="comment">//因为可能会超出length</span></span><br><span class="line"><span class="keyword">int</span> k = low;</span><br><span class="line"><span class="keyword">int</span> left1 = low, right1 = mid;</span><br><span class="line"><span class="keyword">int</span> left2 = mid, right2 = high;</span><br><span class="line"><span class="keyword">while</span> (left1 &lt; right1 &amp;&amp; left2 &lt; right2)<span class="comment">//这里的表达式没有等号，都是左闭右开区间</span></span><br><span class="line">regB[k++] = <span class="built_in">array</span>[left1] &lt; <span class="built_in">array</span>[left2] ? <span class="built_in">array</span>[left1++] : <span class="built_in">array</span>[left2++];</span><br><span class="line"><span class="keyword">while</span> (left1 &lt; right1)</span><br><span class="line">regB[k++] = <span class="built_in">array</span>[left1++];</span><br><span class="line"><span class="keyword">while</span> (left2 &lt; right2)</span><br><span class="line">regB[k++] = <span class="built_in">array</span>[left2++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)<span class="comment">//更新array</span></span><br><span class="line"><span class="built_in">array</span>[i] = regB[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] regB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><ul><li>数据结构    数组</li><li>最坏时间复杂度    ${\displaystyle O(n\log n)}$ </li><li>最优时间复杂度    ${\displaystyle O(n)}$ </li><li>平均时间复杂度    ${\displaystyle O(n\log n)}$ </li><li>空间复杂度    ${\displaystyle O(n)}$</li></ul><p>&emsp;&emsp;比较操作的次数介于 ${\displaystyle (n\log n)/2}$ 和 ${\displaystyle n\log n-n+1}$ 。 赋值操作的次数是 ${\displaystyle (2n\log n)}$ 。归并算法的空间复杂度为： ${\displaystyle \Theta (n)}$。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>&emsp;&emsp;对于归并排序有几点说明：</p><ul><li>和快速排序一样，归并排序在小数组上面的表现不如插入排序。</li><li>辅助数组是一个共用的数组。如果在每个归并的过程中都申请一个临时数组会造成比较大的时间开销。</li><li>归并的过程需要将元素复制到辅助数组，再从辅助数组排序复制回原数组，会拖慢排序速度。</li></ul><p>&emsp;&emsp;归并排序有以下几点优化方法：</p><ul><li>和快速排序一样，对于小数组可以使用插入排序或者选择排序，避免递归调用。（代码见下面的归并排序递归版优化）</li><li>在merge()调用之前，可以判断一下a[mid]是否小于等于a[mid+1]。如果是的话那么就不用归并了，数组已经是有序的。原因很简单，既然两个子数组已经有序了，那么a[mid]是第一个子数组的最大值，a[mid+1]是第二个子数组的最小值。当a[mid]&lt;=a[mid+1]时，数组整体有序。</li><li>为了节省将元素复制到辅助数组作用的时间，可以在递归调用的每个层次交换原始数组与辅助数组的角色。（代码见下面的归并排序迭代版优化）</li></ul><h4 id="递归版优化"><a href="#递归版优化" class="headerlink" title="递归版优化"></a>递归版优化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 归并排序递归版合并函数</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(T *<span class="built_in">array</span>, T *reg, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> left1 = left, right1 = mid;</span><br><span class="line"><span class="keyword">int</span> left2 = mid + <span class="number">1</span>, right2 = right;</span><br><span class="line"><span class="keyword">int</span> k = left;</span><br><span class="line"><span class="keyword">while</span> (left1 &lt;= right1 &amp;&amp; left2 &lt;= right2)</span><br><span class="line">reg[k++] = <span class="built_in">array</span>[left1] &lt; <span class="built_in">array</span>[left2] ? <span class="built_in">array</span>[left1++] : <span class="built_in">array</span>[left2++];</span><br><span class="line"><span class="keyword">while</span> (left1 &lt;= right1)</span><br><span class="line">reg[k++] = <span class="built_in">array</span>[left1++];</span><br><span class="line"><span class="keyword">while</span> (left2 &lt;= right2)</span><br><span class="line">reg[k++] = <span class="built_in">array</span>[left2++];</span><br><span class="line"><span class="keyword">for</span> (k = left; k &lt;= right; k++)</span><br><span class="line"><span class="built_in">array</span>[k] = reg[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 归并排序递归版递归函数优化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSortRecursive1</span><span class="params">(T *<span class="built_in">array</span>, T *reg, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &gt;= right)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (right - left &lt;= M)<span class="comment">//序列长度小于阈值就采用插入排序</span></span><br><span class="line">InsertSort(<span class="built_in">array</span>, left, right);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">MergeSortRecursive1(<span class="built_in">array</span>, reg, left, mid);<span class="comment">//左序列排序</span></span><br><span class="line">MergeSortRecursive1(<span class="built_in">array</span>, reg, mid + <span class="number">1</span>, right);<span class="comment">//右序列排序</span></span><br><span class="line">Merge(<span class="built_in">array</span>, reg, left, mid, right);<span class="comment">//合并左右序列</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span> </span>&#123; </span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">throw</span> invalid_argument(<span class="string">"Array must not be empty"</span>); </span><br><span class="line"><span class="keyword">if</span> (length &lt;= <span class="number">0</span>) </span><br><span class="line"><span class="keyword">return</span>; </span><br><span class="line">T* reg = (T*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(T) * length);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (reg == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fputs</span>(<span class="string">"Error: out of memory\n"</span>, <span class="built_in">stderr</span>);</span><br><span class="line"><span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line">MergeSortRecursive1(<span class="built_in">array</span>, reg, <span class="number">0</span>, length - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">delete</span>[] reg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="迭代版优化"><a href="#迭代版优化" class="headerlink" title="迭代版优化"></a>迭代版优化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 归并排序迭代版优化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSortIteration1</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">throw</span> invalid_argument(<span class="string">"Array must not be empty"</span>);</span><br><span class="line"><span class="keyword">if</span> (length &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">T* regA = <span class="built_in">array</span>;</span><br><span class="line">T* regB = (T*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(T) * length);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (regB == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fputs</span>(<span class="string">"Error: out of memory\n"</span>, <span class="built_in">stderr</span>);</span><br><span class="line"><span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> seg = <span class="number">1</span>; seg &lt; length; seg += seg) &#123;<span class="comment">//步长，每次翻倍</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> left = <span class="number">0</span>; left &lt; length; left += seg + seg) &#123;</span><br><span class="line"><span class="keyword">int</span> low = left, mid = min(left + seg, length), high = min(left + seg + seg, length);<span class="comment">//因为可能会超出length</span></span><br><span class="line"><span class="keyword">int</span> k = low;</span><br><span class="line"><span class="keyword">int</span> left1 = low, right1 = mid;</span><br><span class="line"><span class="keyword">int</span> left2 = mid, right2 = high;</span><br><span class="line"><span class="keyword">while</span> (left1 &lt; right1 &amp;&amp; left2 &lt; right2)<span class="comment">//这里的表达式没有等号，都是左闭右开区间</span></span><br><span class="line">regB[k++] = regA[left1] &lt; regA[left2] ? regA[left1++] : regA[left2++];</span><br><span class="line"><span class="keyword">while</span> (left1 &lt; right1)</span><br><span class="line">regB[k++] = regA[left1++];</span><br><span class="line"><span class="keyword">while</span> (left2 &lt; right2)</span><br><span class="line">regB[k++] = regA[left2++];</span><br><span class="line">&#125;</span><br><span class="line">T* temp = regA;<span class="comment">//优化：交换辅助数组与原始数组的角色</span></span><br><span class="line">regA = regB;</span><br><span class="line">regB = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (regA != <span class="built_in">array</span>) &#123;<span class="comment">//如果regA != array，则说明现在regA是辅助数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)<span class="comment">//所以需要拷贝数据到regB，也就是array。</span></span><br><span class="line">regB[i] = regA[i];</span><br><span class="line">regB = regA;<span class="comment">//regB重新指向辅助数组</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] regB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://marslisiyuan.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="https://marslisiyuan.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="归并排序" scheme="https://marslisiyuan.github.io/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法系列之一：八大排序之快速排序</title>
    <link href="https://marslisiyuan.github.io/2018/01/06/DS/"/>
    <id>https://marslisiyuan.github.io/2018/01/06/DS/</id>
    <published>2018-01-05T16:00:00.000Z</published>
    <updated>2018-08-01T09:22:30.339Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>个人博客：<a href="https://wordzzzz.github.io/" target="_blank" rel="noopener">https://wordzzzz.github.io/</a> &amp;&amp; <a href="https://wordzzzz.gitee.io/" target="_blank" rel="noopener">https://wordzzzz.gitee.io/</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/DS-A" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/DS-A</a></strong></li><li><strong>博客作者：WordZzzz，一只热爱技术的文艺青年</strong></li></ul><hr><p>[toc]</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;建议先看排序综述，传送门：<a href="http://blog.csdn.net/u011475210/article/details/79014021" target="_blank" rel="noopener">数据结构与算法系列之一：八大排序综述</a>。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>&emsp;&emsp;快速排序（英语：Quicksort），又称划分交换排序（partition-exchange sort），一种排序算法，最早由东尼·霍尔提出。在平均状况下，排序 ${\displaystyle n}$ 个项目要 ${\displaystyle O(n\log n)}$ （大O符号）次比较。在最坏状况下则需要 ${\displaystyle O(n^{2})}$ 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 ${\displaystyle O(n\log n)}$ 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>&emsp;&emsp;快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。</p><p>&emsp;&emsp;步骤为：</p><ul><li>从数列中挑出一个元素，称为”基准”（pivot）.</li><li>重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</li><li>递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li><li>递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</li></ul><p>&emsp;&emsp;wikipedia的大数据规模演示：</p><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180108223019362?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="quicksort from wikipedia"></div><br><p></p><p>&emsp;&emsp;wordzzzz的小数据规模演示：</p><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180108223101863?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="quicksort from wordzzzz"></div><br><p></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>&emsp;&emsp;先给出公用接口，之后的三个递归实现和一个迭代实现在代码中都有详细的说明，我就不再在此赘述。</p><h4 id="公用接口"><a href="#公用接口" class="headerlink" title="公用接口"></a>公用接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 快速排序主体函数（递归）</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt; </span><br><span class="line">void QuickSort(T *array, const int length) &#123; </span><br><span class="line">if (array == NULL)</span><br><span class="line">throw invalid_argument(&quot;Array must not be empty&quot;); </span><br><span class="line">if (length &lt;= 0) </span><br><span class="line">return; </span><br><span class="line"></span><br><span class="line">Partion1(array, 0, length - 1);</span><br><span class="line">//  Partion2(array, 0, length - 1);</span><br><span class="line">//  Partion3(array, 0, length - 1);</span><br><span class="line">//PartionInsert(array, 0, length - 1);</span><br><span class="line">//PartionSecond(array, 0, length - 1);</span><br><span class="line">//PartionThird(array, 0, length - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 快速排序1：</span></span><br><span class="line"><span class="comment"> * 将第一个元素array[left]提出来作pivot，i=left(该索引之前的数比pivot小，初始值为left)，</span></span><br><span class="line"><span class="comment"> * j从left+1开始遍历数组，找到一个比pivot小的数，i+1，如果i和j序列号不等就交换（小值到前）。</span></span><br><span class="line"><span class="comment"> * j到最右端之后，for循环结束，再把pivot与i所指数据做交换，当前pivot就到达了它的最终位置。</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Partion1</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &gt;= right)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = left;</span><br><span class="line"><span class="keyword">int</span> j = left + <span class="number">1</span>;</span><br><span class="line">T pivot = <span class="built_in">array</span>[left];<span class="comment">// 取第一个数为基准</span></span><br><span class="line"><span class="keyword">for</span> (; j &lt;= right; ++j)&#123;<span class="comment">// 循环直至 j 扫描至 right</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[j] &lt; pivot)&#123;<span class="comment">// 如果遇到比基准小的数，i右移一位</span></span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span> (j != i)&#123;<span class="comment">// 如果i与j不重合，则交换他们指向的值</span></span><br><span class="line">swap(<span class="built_in">array</span>[j],<span class="built_in">array</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">swap(<span class="built_in">array</span>[left], <span class="built_in">array</span>[i]);<span class="comment">// 基准值的位置确定</span></span><br><span class="line">Partion1(<span class="built_in">array</span>, left, i - <span class="number">1</span>);</span><br><span class="line">Partion1(<span class="built_in">array</span>, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 快速排序2：</span></span><br><span class="line"><span class="comment"> * 将第一个元素array[left]提出来作pivot，i = left+1从左向右遍历找到一个比pivot大的数停止，</span></span><br><span class="line"><span class="comment"> * 然后等待j从右往左遍历找到一个pivot小的数，两者交换，然后继续寻找直到i=j，for循环结束。</span></span><br><span class="line"><span class="comment"> * 之后我们需要做判断，如果pivot比i所指数据大就交换两者，否则i回退一步（因为开始忽略了首元素）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Partion2</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &gt;= right)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = left + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = right;</span><br><span class="line">T pivot = <span class="built_in">array</span>[left];<span class="comment">// 取第一个数为基准</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; j)&#123;<span class="comment">// 循环直至 i,j 相遇</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; <span class="built_in">array</span>[j] &gt;= pivot)<span class="comment">// j向左遍历，直到找到比pivot小的值</span></span><br><span class="line">--j;</span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; <span class="built_in">array</span>[i] &lt; pivot)<span class="comment">// i向右遍历，直到找到比pivot大的值</span></span><br><span class="line">++i;</span><br><span class="line"><span class="keyword">if</span> (i &lt; j)<span class="comment">// 如果i &lt; j，就交换刚才找到的那两个值</span></span><br><span class="line">swap(<span class="built_in">array</span>[j], <span class="built_in">array</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[i] &lt;= <span class="built_in">array</span>[left])<span class="comment">// 这里一定要做判断再决定是否交换</span></span><br><span class="line">swap(<span class="built_in">array</span>[i], <span class="built_in">array</span>[left]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span><span class="comment">// 如果不交换，说明left是最小，但i是不是第二小不确定，所以需要下次判断</span></span><br><span class="line">--i;</span><br><span class="line">Partion2(<span class="built_in">array</span>, left, i - <span class="number">1</span>);</span><br><span class="line">Partion2(<span class="built_in">array</span>, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 快速排序3：</span></span><br><span class="line"><span class="comment"> * 将第一个元素array[left]提出来作pivot，然后从j = right向前搜索第一个比pivot小的元素假设为array[k]，</span></span><br><span class="line"><span class="comment"> * 该元素放在array[left]的位置。因为array[left]已经保存pivot覆盖也没关系，于是array[k]又可以被覆盖了，</span></span><br><span class="line"><span class="comment"> * 从前往后搜索比pivot大的元素放到array[k]。一直进行下去直到i=j。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Partion3</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &gt;= right)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = left;</span><br><span class="line"><span class="keyword">int</span> j = right;</span><br><span class="line">T pivot = <span class="built_in">array</span>[left];<span class="comment">// 取第一个数为基准</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; j)&#123;<span class="comment">// 循环直至 i,j 相遇</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; <span class="built_in">array</span>[j] &gt;= pivot)</span><br><span class="line">--j; </span><br><span class="line"><span class="keyword">if</span> (i &lt; j)</span><br><span class="line"><span class="built_in">array</span>[i++] = <span class="built_in">array</span>[j];<span class="comment">// 从右向左扫描，将比基准小的数填到左边</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; <span class="built_in">array</span>[i] &lt; pivot)</span><br><span class="line">++i; </span><br><span class="line"><span class="keyword">if</span> (i &lt; j)</span><br><span class="line"><span class="built_in">array</span>[j--] = <span class="built_in">array</span>[i];<span class="comment">// 从左向右扫描，将比基准大的数填到右边</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">array</span>[i] = pivot;<span class="comment">// 将基准数填回</span></span><br><span class="line">Partion3(<span class="built_in">array</span>, left, i - <span class="number">1</span>);</span><br><span class="line">Partion3(<span class="built_in">array</span>, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 快速排序迭代实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSortIteration</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; trace;</span><br><span class="line">trace.push(make_pair(<span class="number">0</span>, length - <span class="number">1</span>));<span class="comment">// 将数组首尾压栈</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!trace.empty()) &#123;</span><br><span class="line"><span class="keyword">auto</span> top = trace.top();<span class="comment">// 将栈顶元素保存下来</span></span><br><span class="line">trace.pop();<span class="comment">// 弹出栈顶</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = top.first;<span class="comment">// 取出首尾地址</span></span><br><span class="line"><span class="keyword">int</span> j = top.second;</span><br><span class="line"></span><br><span class="line">T pivot = <span class="built_in">array</span>[i];<span class="comment">// 取第一个数为基准</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt; j) &#123;<span class="comment">// 循环直至 i,j 相遇</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; <span class="built_in">array</span>[j] &gt;= pivot)</span><br><span class="line">--j;</span><br><span class="line"><span class="keyword">if</span> (i &lt; j)</span><br><span class="line"><span class="built_in">array</span>[i++] = <span class="built_in">array</span>[j];<span class="comment">// 从右向左扫描，将比基准小的数填到左边</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; <span class="built_in">array</span>[i] &lt; pivot)</span><br><span class="line">++i;</span><br><span class="line"><span class="keyword">if</span> (i &lt; j)</span><br><span class="line"><span class="built_in">array</span>[j--] = <span class="built_in">array</span>[i];<span class="comment">// 从左向右扫描，将比基准大的数填到右边</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">array</span>[i] = pivot;<span class="comment">// 将基准数填回</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i &gt; top.first) trace.push(make_pair(top.first, i - <span class="number">1</span>));</span><br><span class="line"><span class="keyword">if</span> (j &lt; top.second) trace.push(make_pair(j + <span class="number">1</span>, top.second));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><ul><li>数据结构    不定</li><li>最坏时间复杂度    ${\displaystyle O(n^{2})}$ </li><li>最优时间复杂度    ${\displaystyle O(n\log n)}$ </li><li>平均时间复杂度    ${\displaystyle O(n\log n)}$ </li><li>空间复杂度    根据实现的方式不同而不同</li></ul><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>&emsp;&emsp;快速排序是二叉查找树（二叉查找树）的一个空间最优化版本。不是循序地把数据项插入到一个明确的树中，而是由快速排序组织这些数据项到一个由递归调用所隐含的树中。这两个算法完全地产生相同的比较次数，但是顺序不同。对于排序算法的稳定性指标，原地分区版本的快速排序算法是不稳定的。其他变种是可以通过牺牲性能和空间来维护稳定性的。</p><p>&emsp;&emsp;快速排序的最直接竞争者是堆排序（Heapsort）。堆排序通常比快速排序稍微慢，但是最坏情况的运行时间总是 ${\displaystyle O(n\log n)}$ 。快速排序是经常比较快，除了introsort变化版本外，仍然有最坏情况性能的机会。如果事先知道堆排序将会是需要使用的，那么直接地使用堆排序比等待introsort再切换到它还要快。堆排序也拥有重要的特点，仅使用固定额外的空间（堆排序是原地排序），而即使是最佳的快速排序变化版本也需要 ${\displaystyle O(\log n)}$ 的空间。然而，堆排序需要有效率的随机存取才能变成可行。</p><p>&emsp;&emsp;快速排序也与归并排序（Mergesort）竞争，这是另外一种递归排序算法，但有坏情况 ${\displaystyle O(n\log n)}$ 运行时间的优势。不像快速排序或堆排序，归并排序是一个稳定排序，且可以轻易地被采用在链表（linked list）和存储在慢速访问媒体上像是磁盘存储或网络连接存储的非常巨大数列。尽管快速排序可以被重新改写使用在链串列上，但是它通常会因为无法随机存取而导致差的基准选择。归并排序的主要缺点，是在最佳情况下需要 ${\displaystyle \Omega (n)}$ 额外的空间。</p><h4 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h4><p>&emsp;&emsp;快排的优化、归并排序的优化一向是面试的考察重点，至于算法的优化，重点还是要知道现有算法的不足之处。</p><ul><li>当序列长度很小时，快排效率低，研究表明长度在5~25的数组，快排表现不如插入排序。</li><li>当pivot选择不当是，会导致树的不平衡，这样导致快排的时间复杂度为${\displaystyle O(n^{2})}$。</li><li>当数组中有大量重复的元素，快排效率将非常之低。</li></ul><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>&emsp;&emsp;针对上面提出的快排的局限性，我们依次做出优化策略：</p><ul><li>当当前序列长度小于特定值时，直接采用插入排序，或者不做处理，等到快排都执行完毕后（大致有序）在执行一次插入排序。</li><li>针对pivot的选择，不再选取固定值，而是采用其他选取策略，如随机、三值取中等。</li><li>如果数组中重复元素多，就采用三路划分算法：以某个数为基准将一个数组分成三部分：第一部分表示小于该pivot，第二部分等于pivot，第三部分大于pivot，要得到三部分得区间范围。</li></ul><p>&emsp;&emsp;下面的代码是对上述改进算法的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 快速排序3优化1：</span></span><br><span class="line"><span class="comment">* 当排序的子序列小于预定的值M时，采用插入排序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PartionInsert</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &gt;= right)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (right - left &lt;= M)</span><br><span class="line">InsertSort(<span class="built_in">array</span>, left, right);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = left;</span><br><span class="line"><span class="keyword">int</span> j = right;</span><br><span class="line">T pivot = <span class="built_in">array</span>[left];<span class="comment">// 取第一个数为基准</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; j)&#123;<span class="comment">// 循环直至 i,j 相遇</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; <span class="built_in">array</span>[j] &gt;= pivot)</span><br><span class="line">--j;</span><br><span class="line"><span class="keyword">if</span> (i &lt; j)</span><br><span class="line"><span class="built_in">array</span>[i++] = <span class="built_in">array</span>[j];<span class="comment">// 从右向左扫描，将比基准小的数填到左边</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; <span class="built_in">array</span>[i] &lt; pivot)</span><br><span class="line">++i;</span><br><span class="line"><span class="keyword">if</span> (i &lt; j)</span><br><span class="line"><span class="built_in">array</span>[j--] = <span class="built_in">array</span>[i];<span class="comment">// 从左向右扫描，将比基准大的数填到右边</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">array</span>[i] = pivot;<span class="comment">// 将基准数填回</span></span><br><span class="line">PartionInsert(<span class="built_in">array</span>, left, i - <span class="number">1</span>);</span><br><span class="line">PartionInsert(<span class="built_in">array</span>, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//产生随机数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Random</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> size = right - left + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> i = left + rand() % size;</span><br><span class="line">swap(<span class="built_in">array</span>[i], <span class="built_in">array</span>[left]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取中位数移至left</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Median</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid = left + ((right - left )&gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> minIndex = right;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[minIndex] &gt; <span class="built_in">array</span>[mid])</span><br><span class="line">minIndex = mid;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[minIndex] &gt; <span class="built_in">array</span>[left])</span><br><span class="line">minIndex = left;</span><br><span class="line"><span class="keyword">if</span> (minIndex != right)<span class="comment">//三个判断，把最小值移到最右侧</span></span><br><span class="line">swap(<span class="built_in">array</span>[minIndex], <span class="built_in">array</span>[right]);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[mid] &lt; <span class="built_in">array</span>[left])<span class="comment">//那么剩下的两个数，最小的那个就是中位数了</span></span><br><span class="line">swap(<span class="built_in">array</span>[left], <span class="built_in">array</span>[mid]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 快速排序3优化2：</span></span><br><span class="line"><span class="comment">* 取随机数或者三值取中作为基准值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PartionSecond</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &gt;= right)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Random(array, left, right);// 优化2-1：取随机数至最左端（基准值）</span></span><br><span class="line">Median(<span class="built_in">array</span>, left, right);<span class="comment">// 优化2-2：取中位数至最左端（基准值）</span></span><br><span class="line"><span class="keyword">int</span> i = left;</span><br><span class="line"><span class="keyword">int</span> j = right;</span><br><span class="line">T pivot = <span class="built_in">array</span>[left];<span class="comment">// 取第一个数为基准</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; j)&#123;<span class="comment">// 循环直至 i,j 相遇</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; <span class="built_in">array</span>[j] &gt;= pivot)</span><br><span class="line">--j;</span><br><span class="line"><span class="keyword">if</span> (i &lt; j)</span><br><span class="line"><span class="built_in">array</span>[i++] = <span class="built_in">array</span>[j];<span class="comment">// 从右向左扫描，将比基准小的数填到左边</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; <span class="built_in">array</span>[i] &lt; pivot)</span><br><span class="line">++i;</span><br><span class="line"><span class="keyword">if</span> (i &lt; j)</span><br><span class="line"><span class="built_in">array</span>[j--] = <span class="built_in">array</span>[i];<span class="comment">// 从左向右扫描，将比基准大的数填到右边</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">array</span>[i] = pivot;<span class="comment">// 将基准数填回</span></span><br><span class="line">PartionSecond(<span class="built_in">array</span>, left, i - <span class="number">1</span>);</span><br><span class="line">PartionSecond(<span class="built_in">array</span>, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 快速排序3优化3：</span></span><br><span class="line"><span class="comment">* 重复数据比较多的话，可以分为小于等于大于三段</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PartionThird</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &gt;= right)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> less = left;</span><br><span class="line"><span class="keyword">int</span> greater = right;</span><br><span class="line"><span class="keyword">int</span> it = left;</span><br><span class="line">T pivot = <span class="built_in">array</span>[left];<span class="comment">// 取第一个数为基准</span></span><br><span class="line"><span class="keyword">while</span> (it &lt;= greater)&#123;<span class="comment">// 循环直至it和greater相遇</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[it] == pivot)<span class="comment">// 如果等于pivot，it右移</span></span><br><span class="line">++it;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">array</span>[it] &lt; pivot)&#123;<span class="comment">// 如果小于pivot，扔左边，it和less右移</span></span><br><span class="line">swap(<span class="built_in">array</span>[less], <span class="built_in">array</span>[it]);</span><br><span class="line">++it;</span><br><span class="line">++less;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;<span class="comment">// 如果大于pivot，扔右边，greater左移</span></span><br><span class="line">swap(<span class="built_in">array</span>[greater], <span class="built_in">array</span>[it]);</span><br><span class="line">--greater;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">PartionThird(<span class="built_in">array</span>, left, less - <span class="number">1</span>);</span><br><span class="line">PartionThird(<span class="built_in">array</span>, greater + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://marslisiyuan.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="https://marslisiyuan.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="快速排序" scheme="https://marslisiyuan.github.io/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法系列之一：八大排序之冒泡排序</title>
    <link href="https://marslisiyuan.github.io/2018/01/05/DS/"/>
    <id>https://marslisiyuan.github.io/2018/01/05/DS/</id>
    <published>2018-01-04T16:00:00.000Z</published>
    <updated>2018-08-01T09:22:30.339Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>个人博客：<a href="https://wordzzzz.github.io/" target="_blank" rel="noopener">https://wordzzzz.github.io/</a> &amp;&amp; <a href="https://wordzzzz.gitee.io/" target="_blank" rel="noopener">https://wordzzzz.gitee.io/</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/DS-A" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/DS-A</a></strong></li><li><strong>博客作者：WordZzzz，一只热爱技术的文艺青年</strong></li></ul><hr><p>[toc]</p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;建议先看排序综述，传送门：<a href="http://blog.csdn.net/u011475210/article/details/79014021" target="_blank" rel="noopener">数据结构与算法系列之一：八大排序综述</a>。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>&emsp;&emsp;冒泡排序（英语：Bubble Sort，台湾另外一种译名为：泡沫排序）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><p>&emsp;&emsp;冒泡排序对 ${\displaystyle n}$ 个项目需要${\displaystyle O(n)}$ )的比较次数，且可以原地排序。尽管这个算法是最简单了解和实现的排序算法之一，但它对于包含大量的元素的数列排序是很没有效率的。</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>冒泡排序算法的运作如下：</p><ul><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ul><p>由于它的简洁，冒泡排序通常被用来对于程序设计入门的学生介绍算法的概念。</p><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>&emsp;&emsp;wikipedia的大数据规模演示：</p><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180108094645331?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="bubblesort from wikipedia"></div><br><p></p><p>&emsp;&emsp;wordzzzz的小数据规模演示：</p><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180108095446582?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="bubblesort from wordzzzz"></div><br><p></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 标准冒泡排序：嵌套循环比大小。</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">throw</span> invalid_argument(<span class="string">"Array must not be empty"</span>);</span><br><span class="line"><span class="keyword">if</span> (length &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; ++i)&#123;<span class="comment">//外循环，每次循环确定一个最大值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length - <span class="number">1</span> - i; ++j)&#123;<span class="comment">//内循环，用于交换数据，遍历次数递减</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[j] &gt; <span class="built_in">array</span>[j + <span class="number">1</span>])&#123;<span class="comment">//如果当前数据比后面的数据大，则交换</span></span><br><span class="line">T tmp = <span class="built_in">array</span>[j + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">array</span>[j + <span class="number">1</span>] = <span class="built_in">array</span>[j];</span><br><span class="line"><span class="built_in">array</span>[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><ul><li>数据结构    数组</li><li>最坏时间复杂度    ${\displaystyle O(n^{2})}$</li><li>最优时间复杂度    ${\displaystyle O(n)}$</li><li>平均时间复杂度    ${\displaystyle O(n^{2})}$</li><li>空间复杂度    总共 ${\displaystyle O(n)}$，需要辅助空间 ${\displaystyle O(1)}$</li></ul><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>&emsp;&emsp;冒泡排序是与插入排序拥有相等的运行时间，但是两种算法在需要的交换次数却很大地不同。在最坏的情况，冒泡排序需要 ${\displaystyle O(n^{2})}$次交换，而插入排序只要最多 ${\displaystyle O(n)}$ 交换。冒泡排序的实现（类似上面）通常会对已经排序好的数列拙劣地运行（ ${\displaystyle O(n^{2})}$ ），而插入排序在这个例子只需要 ${\displaystyle O(n)}$ 个运算。因此很多现代的算法教科书避免使用冒泡排序，而用插入排序取代之。</p><p>&emsp;&emsp;在面试中，一般都会涉及到算法的优化，重点考察的其实还是你对现有算法的理解，分析现有算法的缺点，就能找到优化的思路。</p><p>优化1：冒泡排序如果能在内部循环第一次运行时，使用一个旗标来表示有无需要交换的可能，也可以把最优情况下的复杂度降低到 ${\displaystyle O(n)}$ 。在这个情况，已经排序好的数列就无交换的需要。<br>优化2：可以记录某次遍历时最后发生数据交换的位置，这个位置之后的数据显然已经有序，不用再排序了。因此通过记录最后发生数据交换的位置就可以确定下次循环的范围了。<br>优化3：若在每次走访数列时，把走访顺序反过来，也可以稍微地改进效率。有时候称为鸡尾酒排序，因为算法会从数列的一端到另一端之间穿梭往返。</p><p>优化代码如下：</p><p>优化1：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 冒泡排序优化1：如果某次内循环没有改变任何数据，则结束。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort1</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span> </span>&#123; </span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">throw</span> invalid_argument(<span class="string">"Array must not be empty"</span>); </span><br><span class="line"><span class="keyword">if</span> (length &lt;= <span class="number">0</span>) </span><br><span class="line"><span class="keyword">return</span>; </span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;<span class="comment">//设置标志位，用来判断内循环是否有数据交换</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; ++i)&#123;<span class="comment">//外循环，每次循环确定一个最大值</span></span><br><span class="line">flag = <span class="literal">false</span>;<span class="comment">//外循环第一步需要重置标志位</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length - <span class="number">1</span> - i; ++j)&#123;<span class="comment">//内循环，用于交换数据，遍历次数递减</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[j] &gt; <span class="built_in">array</span>[j + <span class="number">1</span>])&#123;<span class="comment">//如果当前数据比后面的数据大，则交换</span></span><br><span class="line">T tmp = <span class="built_in">array</span>[j + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">array</span>[j + <span class="number">1</span>] = <span class="built_in">array</span>[j];</span><br><span class="line"><span class="built_in">array</span>[j] = tmp;</span><br><span class="line">flag = <span class="literal">true</span>;<span class="comment">//如果有交换，则标志位置1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!flag) <span class="keyword">return</span>;<span class="comment">//如果本次循环没有数据交换，则结束排序</span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化2：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 冒泡排序优化2：在优化1的基础上，记录上次排序结束位置，减少排序次数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort2</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">throw</span> invalid_argument(<span class="string">"Array must not be empty"</span>);</span><br><span class="line"><span class="keyword">if</span> (length &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> k = length;</span><br><span class="line"><span class="keyword">int</span> flag = k;<span class="comment">//设置标志位，用来判断内循环是否有数据交换</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; ++i)&#123;<span class="comment">//外循环，每次循环确定一个最大值</span></span><br><span class="line">k = flag;</span><br><span class="line">flag = <span class="number">0</span>;<span class="comment">//外循环第一步需要重置标志位</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k - <span class="number">1</span>; ++j)&#123;<span class="comment">//内循环，用于交换数据，遍历次数递减</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[j] &gt; <span class="built_in">array</span>[j + <span class="number">1</span>])&#123;<span class="comment">//如果当前数据比后面的数据大，则交换</span></span><br><span class="line">T tmp = <span class="built_in">array</span>[j + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">array</span>[j + <span class="number">1</span>] = <span class="built_in">array</span>[j];</span><br><span class="line"><span class="built_in">array</span>[j] = tmp;</span><br><span class="line">flag = j + <span class="number">1</span>;<span class="comment">//如果有交换，更新交换位置的记录</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!flag) <span class="keyword">return</span>;<span class="comment">//如果本次循环没有数据交换，则结束排序</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化3：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *冒泡排序优化3：鸡尾酒排序，一个外循环内跑两个内循环。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort3</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">throw</span> invalid_argument(<span class="string">"Array must not be empty"</span>);</span><br><span class="line"><span class="keyword">if</span> (length &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> high = length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (high &gt; low)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = low; i &lt; high; ++i)<span class="comment">//正向冒泡，确定最大值  </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[i] &gt; <span class="built_in">array</span>[i + <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">T temp = <span class="built_in">array</span>[i];</span><br><span class="line"><span class="built_in">array</span>[i] = <span class="built_in">array</span>[i + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">array</span>[i + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">--high;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = high; j &gt; low; --j)<span class="comment">//反向冒泡，确定最小值  </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[j] &lt; <span class="built_in">array</span>[j - <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">T temp = <span class="built_in">array</span>[j];</span><br><span class="line"><span class="built_in">array</span>[j] = <span class="built_in">array</span>[j - <span class="number">1</span>];</span><br><span class="line"><span class="built_in">array</span>[j - <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">++low;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://marslisiyuan.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="https://marslisiyuan.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="冒泡排序" scheme="https://marslisiyuan.github.io/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法系列之一：八大排序之堆排序</title>
    <link href="https://marslisiyuan.github.io/2018/01/04/DS/"/>
    <id>https://marslisiyuan.github.io/2018/01/04/DS/</id>
    <published>2018-01-03T16:00:00.000Z</published>
    <updated>2018-08-01T09:22:30.339Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>个人博客：<a href="https://wordzzzz.github.io/" target="_blank" rel="noopener">https://wordzzzz.github.io/</a> &amp;&amp; <a href="https://wordzzzz.gitee.io/" target="_blank" rel="noopener">https://wordzzzz.gitee.io/</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/DS-A" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/DS-A</a></strong></li><li><strong>博客作者：WordZzzz，一只热爱技术的文艺青年</strong></li></ul><hr><p>[toc]</p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;建议先看排序综述，传送门：<a href="http://blog.csdn.net/u011475210/article/details/79014021" target="_blank" rel="noopener">数据结构与算法系列之一：八大排序综述</a>。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>&emsp;&emsp;堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><p>&emsp;&emsp;通常堆是通过一维数组来实现的。在数组起始位置为0的情形中：</p><ul><li>父节点i的左子节点在位置 ${\displaystyle (2i+1)}$。</li><li>父节点i的右子节点在位置 ${\displaystyle (2i+2)}$。</li><li>子节点i的父节点在位置 ${\displaystyle floor((i-1)/2)}$。</li></ul><p>&emsp;&emsp;在堆的数据结构中，堆中的最大值总是位于根节点(在优先队列中使用堆的话堆中的最小值位于根节点)。堆中定义以下几种操作：</p><ul><li>最大堆调整（Max_Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点。</li><li>创建最大堆（Build_Max_Heap）：将堆所有数据重新排序。</li><li>堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算。</li></ul><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>&emsp;&emsp;基于以上堆相关的操作，我们可以很容易的定义堆排序。例如，假设我们已经读入一系列数据并创建了一个堆，一个最直观的算法就是反复的调用del_max()函数，因为该函数总是能够返回堆中最大的值，然后把它从堆中删除，从而对这一系列返回值的输出就得到了该序列的降序排列。真正的原地堆排序使用了另外一个小技巧。堆排序的过程是：</p><ul><li>创建一个堆 ${\displaystyle H[0..n-1]}$。</li><li>把堆首（最大值）和堆尾互换。</li><li>把堆的尺寸缩小1，并调用shift_down(0),目的是把新的数组顶端数据调整到相应位置。</li><li>重复步骤2，直到堆的尺寸为1。</li></ul><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>&emsp;&emsp;wikipedia的大数据规模演示：</p><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180108145757178?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="heapsort from wikipedia"></div><br><p></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="递归版"><a href="#递归版" class="headerlink" title="递归版"></a>递归版</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 堆排序递归版</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MaxHeapifyRecursive</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">int</span> i, <span class="keyword">int</span> heapSize)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sonl = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> sonr = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> dad = i;</span><br><span class="line"><span class="keyword">if</span> (sonl &lt;= heapSize &amp;&amp; <span class="built_in">array</span>[sonl]&gt;<span class="built_in">array</span>[i])&#123;<span class="comment">//如果左子结点大于父结点，则父结点指向子结点</span></span><br><span class="line">dad = sonl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sonr &lt;= heapSize &amp;&amp; <span class="built_in">array</span>[sonr]&gt;<span class="built_in">array</span>[dad])&#123;<span class="comment">//如果右子结点大于父结点，则父结点指向子结点</span></span><br><span class="line">dad = sonr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dad != i)&#123;<span class="comment">//如果dad != i则说明父结点不是最大值，交换后递归执行MaxHeapifyRecursive</span></span><br><span class="line">swap(<span class="built_in">array</span>[i], <span class="built_in">array</span>[dad]);</span><br><span class="line">MaxHeapifyRecursive(<span class="built_in">array</span>, dad, heapSize);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">throw</span> invalid_argument(<span class="string">"Array must not be empty"</span>);</span><br><span class="line"><span class="keyword">if</span> (length &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化，i从最后一个父结点开始调整</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line"><span class="comment">//构建最大堆 </span></span><br><span class="line">MaxHeapifyRecursive(<span class="built_in">array</span>, i, length - <span class="number">1</span>);</span><br><span class="line"><span class="comment">//MaxHeapifyIteration(array, i, length - 1);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先将第一个元素和已经排好的元素前一位做交换，再从新调整（刚调整的元素之前的元素），直到排序完毕</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">swap(<span class="built_in">array</span>[<span class="number">0</span>], <span class="built_in">array</span>[i]);</span><br><span class="line">MaxHeapifyRecursive(<span class="built_in">array</span>, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line"><span class="comment">//MaxHeapifyIteration(array, 0, i - 1);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="迭代版"><a href="#迭代版" class="headerlink" title="迭代版"></a>迭代版</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 堆排序迭代版</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MaxHeapifyIteration</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="comment">//建立父结点指针和子结点指针</span></span><br><span class="line"><span class="keyword">int</span> dad = left;</span><br><span class="line"><span class="keyword">int</span> son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (son &lt;= right) &#123;<span class="comment">//若子结点指针在范围内才做比较</span></span><br><span class="line"><span class="keyword">if</span> (son + <span class="number">1</span> &lt;= right &amp;&amp; <span class="built_in">array</span>[son] &lt; <span class="built_in">array</span>[son + <span class="number">1</span>])<span class="comment">//先比较两个子结点的大小，选择最大的</span></span><br><span class="line">son++;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[dad] &gt; <span class="built_in">array</span>[son])<span class="comment">//如果父结点大于子结点代表调整完毕，直接跳出循环</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//否则交换父子内容在继续子结点和孙结点的比较</span></span><br><span class="line">swap(<span class="built_in">array</span>[dad], <span class="built_in">array</span>[son]);</span><br><span class="line">dad = son;</span><br><span class="line">son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">throw</span> invalid_argument(<span class="string">"Array must not be empty"</span>);</span><br><span class="line"><span class="keyword">if</span> (length &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化，i从最后一个父结点开始调整</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line"><span class="comment">//构建最大堆 </span></span><br><span class="line"><span class="comment">//MaxHeapifyRecursive(array, i, length - 1);</span></span><br><span class="line">MaxHeapifyIteration(<span class="built_in">array</span>, i, length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先将第一个元素和已经排好的元素前一位做交换，再从新调整（刚调整的元素之前的元素），直到排序完毕</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">swap(<span class="built_in">array</span>[<span class="number">0</span>], <span class="built_in">array</span>[i]);</span><br><span class="line"><span class="comment">//MaxHeapifyRecursive(array, 0, i - 1);</span></span><br><span class="line">MaxHeapifyIteration(<span class="built_in">array</span>, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><ul><li>数据结构    数组</li><li>最坏时间复杂度    ${\displaystyle O(n\log n)}$</li><li>最优时间复杂度    ${\displaystyle O(n\log n)}$</li><li>平均时间复杂度    ${\displaystyle O(n\log n)}$ </li><li>空间复杂度    ${\displaystyle O(n)}$ total, ${\displaystyle O(1)}$ auxiliary</li></ul><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>&emsp;&emsp;原地堆排序已经是空间优化版本了，因为它不再需要申请额外的空间。</p><p>&emsp;&emsp;整个算法的过程分为建堆和排序两个过程，首先对现有数组建立最大堆，然后一边提取堆顶的最大值，一边减小堆的尺寸，最后堆尺寸为1时，排序也就完成了。如果大家对整个算法的执行过程不太了解，可以看一下下面这两张图，第一张是建堆的过程示意图，第二张是排序的过程示意图。图片来自：<a href="http://bubkoo.com/2014/01/14/sort-algorithm/heap-sort/" target="_blank" rel="noopener">http://bubkoo.com/2014/01/14/sort-algorithm/heap-sort/</a></p><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180108145915265?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="bubblesort from wordzzzz"></div><br><p></p><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180108145935165?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="bubblesort from wordzzzz"></div><br><p></p><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://marslisiyuan.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="https://marslisiyuan.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="堆排序" scheme="https://marslisiyuan.github.io/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法系列之一：八大排序之选择排序</title>
    <link href="https://marslisiyuan.github.io/2018/01/03/DS/"/>
    <id>https://marslisiyuan.github.io/2018/01/03/DS/</id>
    <published>2018-01-02T16:00:00.000Z</published>
    <updated>2018-08-01T09:22:30.338Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>个人博客：<a href="https://wordzzzz.github.io/" target="_blank" rel="noopener">https://wordzzzz.github.io/</a> &amp;&amp; <a href="https://wordzzzz.gitee.io/" target="_blank" rel="noopener">https://wordzzzz.gitee.io/</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/DS-A" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/DS-A</a></strong></li><li><strong>博客作者：WordZzzz，一只热爱技术的文艺青年</strong></li></ul><hr><p>[toc]</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;建议先看排序综述，传送门：<a href="http://blog.csdn.net/u011475210/article/details/79014021" target="_blank" rel="noopener">数据结构与算法系列之一：八大排序综述</a>。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>&emsp;&emsp;选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><p>&emsp;&emsp;选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对 ${\displaystyle n}$ 个元素的表进行排序总共进行至多 ${\displaystyle n-1}$ 次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul><li>找到列表中的最小值。</li><li>把它和第一个位置的元素交换。</li><li>列表其余部分重复上面的步骤(从第二个位置开始，且每次加1)。</li></ul><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>&emsp;&emsp;wikipedia的大数据规模演示：</p><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180108111324944?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="selectsort from wikipedia"></div><br><p></p><p>&emsp;&emsp;wordzzzz的小数据规模演示：</p><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180108111351977?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="selectsort from wordzzzz"></div><br><p></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*直接选择排序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">throw</span> invalid_argument(<span class="string">"Array must not be empty"</span>);</span><br><span class="line"><span class="keyword">if</span> (length &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; ++i)&#123;<span class="comment">//外循环，每次选出一个最小的元素放到前面</span></span><br><span class="line"><span class="keyword">int</span> min = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; length; ++j)<span class="comment">//内循环，确定最小元素的下标</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[j] &lt; <span class="built_in">array</span>[min])</span><br><span class="line">min = j;</span><br><span class="line"><span class="keyword">if</span> (min != i)&#123;<span class="comment">//如果当前数据不是最小元素，就交换</span></span><br><span class="line">T tmp = <span class="built_in">array</span>[i];</span><br><span class="line"><span class="built_in">array</span>[i] = <span class="built_in">array</span>[min];</span><br><span class="line"><span class="built_in">array</span>[min] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><ul><li>数据结构    数组</li><li>最坏时间复杂度    ${\displaystyle O(n^2)}$ </li><li>最优时间复杂度    ${\displaystyle O(n^2)}$</li><li>平均时间复杂度    ${\displaystyle O(n^2)}$</li><li>空间复杂度    ${\displaystyle O(n)}$ total, ${\displaystyle O(1)}$ auxiliary</li></ul><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>&emsp;&emsp;选择排序的交换操作介于 ${\displaystyle 0}$ 和 ${\displaystyle (n-1)}$ 次之间。选择排序的比较操作为 ${\displaystyle n(n-1)/2}$ 次之间。选择排序的赋值操作介于 ${\displaystyle 0}$ 和 ${\displaystyle 3(n-1)}$ 次之间。</p><p>&emsp;&emsp;比较次数 ${\displaystyle O(n^{2})}$ ，比较次数与关键字的初始状态无关，总的比较次数 ${\displaystyle N=(n-1)+(n-2)+…+1=n\times (n-1)/2}$ 。交换次数 ${\displaystyle O(n)}$ ，最好情况是，已经有序，交换0次；最坏情况是，逆序，交换 ${\displaystyle n-1} 次。交换次数比冒泡排序较少，由于交换所需CPU时间比比较所需的CPU时间多， ${\displaystyle n}$ 值较小时，选择排序比冒泡排序快。</p><p>&emsp;&emsp;原地操作几乎是选择排序的唯一优点，当空间复杂度要求较高时，可以考虑选择排序；实际适用的场合非常罕见。</p><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://marslisiyuan.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="https://marslisiyuan.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="选择排序" scheme="https://marslisiyuan.github.io/tags/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法系列之一：八大排序之希尔排序</title>
    <link href="https://marslisiyuan.github.io/2018/01/02/DS/"/>
    <id>https://marslisiyuan.github.io/2018/01/02/DS/</id>
    <published>2018-01-01T16:00:00.000Z</published>
    <updated>2018-08-01T09:22:30.338Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>个人博客：<a href="https://wordzzzz.github.io/" target="_blank" rel="noopener">https://wordzzzz.github.io/</a> &amp;&amp; <a href="https://wordzzzz.gitee.io/" target="_blank" rel="noopener">https://wordzzzz.gitee.io/</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/DS-A" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/DS-A</a></strong></li><li><strong>博客作者：WordZzzz，一只热爱技术的文艺青年</strong></li></ul><hr><p>[toc]</p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;建议先看排序综述，传送门：<a href="http://blog.csdn.net/u011475210/article/details/79014021" target="_blank" rel="noopener">数据结构与算法系列之一：八大排序综述</a>。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>&emsp;&emsp;希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。</p><p>&emsp;&emsp;希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><p>&emsp;&emsp;插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率<br>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>&emsp;&emsp;原始的算法实现在最坏的情况下需要进行${\displaystyle O(n^{2})}$ 的比较和交换。V. Pratt的书对算法进行了少量修改，可以使得性能提升至${\displaystyle O(n\log ^{2}n)}$ 。这比最好的比较算法的${\displaystyle O(n\log n)}$ 要差一些。</p><p>&emsp;&emsp;希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。</p><p>&emsp;&emsp;假设有一个很小的数据在一个已按升序排好序的数组的末端。如果用复杂度为O(n2)的排序（冒泡排序或插入排序），可能会进行n次的比较和交换才能将该数据移至正确位置。而希尔排序会用较大的步长移动数据，所以小数据只需进行少数比较和交换即可到正确位置。</p><p>&emsp;&emsp;一个更好理解的希尔排序实现：将数组列在一个表中并对列排序（用插入排序）。重复这过程，不过每次用更长的列来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身仅仅对原数组进行排序（通过增加索引的步长，例如是用i += step_size而不是i++）。</p><p>&emsp;&emsp;例如，假设有这样一组数[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">13 14 94 33 82</span><br><span class="line">25 59 94 65 23</span><br><span class="line">45 27 73 25 39</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后我们对每列进行排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10 14 73 25 23</span><br><span class="line">13 27 94 33 39</span><br><span class="line">25 59 94 65 82</span><br><span class="line">45</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;将上述四行数字，依序接在一起时我们得到：[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ].这时10已经移至正确位置了，然后再以3为步长进行排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">10 14 73</span><br><span class="line">25 23 13</span><br><span class="line">27 94 33</span><br><span class="line">39 25 59</span><br><span class="line">94 65 82</span><br><span class="line">45</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;排序之后变为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">10 14 13</span><br><span class="line">25 23 33</span><br><span class="line">27 25 59</span><br><span class="line">39 65 73</span><br><span class="line">45 94 82</span><br><span class="line">94</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最后以1步长进行排序（此时就是简单的插入排序了）。</p><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>&emsp;&emsp;wikipedia的大数据规模演示：</p><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180108104308360?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="shellsort from wikipedia"></div><br><p></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 希尔排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">throw</span> invalid_argument(<span class="string">"Array must not be empty"</span>);</span><br><span class="line"><span class="keyword">if</span> (length &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> gap = length &gt;&gt; <span class="number">1</span>; gap &gt; <span class="number">0</span>; gap &gt;&gt;= <span class="number">1</span>)&#123;<span class="comment">//gap是设置的步长</span></span><br><span class="line">T tmp;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; length; ++i)&#123;</span><br><span class="line">tmp = <span class="built_in">array</span>[i];</span><br><span class="line"><span class="keyword">int</span> j = i;<span class="comment">//后面要用到j，所以在for循环的外面初始化</span></span><br><span class="line"><span class="keyword">while</span> (j &gt;= gap &amp;&amp; tmp &lt; <span class="built_in">array</span>[j - gap])&#123;</span><br><span class="line"><span class="built_in">array</span>[j] = <span class="built_in">array</span>[j - gap];</span><br><span class="line">j -= gap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">array</span>[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><ul><li>数据结构    数组</li><li>最坏时间复杂度    根据步长序列的不同而不同。已知最好的： ${\displaystyle O(n\log ^{2}n)}$ </li><li>最优时间复杂度    ${\displaystyle O(n)}$</li><li>平均时间复杂度    根据步长序列的不同而不同。</li><li>空间复杂度        ${\displaystyle O(n)}$</li></ul><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>&emsp;&emsp;步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。算法最开始以一定的步长进行排序。然后会继续以一定步长进行排序，最终算法以步长为1进行排序。当步长为1时，算法变为插入排序，这就保证了数据一定会被排序。</p><p>&emsp;&emsp;Donald Shell最初建议步长选择为 ${\displaystyle {\frac {n}{2}}}$ 并且对步长取半直到步长达到1。虽然这样取可以比 ${\displaystyle O(n^{2})}$ 类的算法（插入排序）更好，但这样仍然有减少平均时间和最差时间的余地。可能希尔排序最重要的地方在于当用较小步长排序后，以前用的较大步长仍然是有序的。比如，如果一个数列以步长5进行了排序然后再以步长3进行排序，那么该数列不仅是以步长3有序，而且是以步长5有序。如果不是这样，那么算法在迭代过程中会打乱以前的顺序，那就不会以如此短的时间完成排序了。</p><table><thead><tr><th>步长序列</th><th>最坏情况下复杂度</th></tr></thead><tbody><tr><td>${\displaystyle {n/2^{i}}}$</td><td>${\displaystyle O(n^{2})}$</td></tr><tr><td>${\displaystyle 2^{k}-1}$</td><td>${\displaystyle O(n^{3/2})}$</td></tr><tr><td>${\displaystyle 2^{i}3^{j}}$</td><td>${\displaystyle O(n\log ^{2}n)}$</td></tr></tbody></table><p>&emsp;&emsp;已知的最好步长序列是由Sedgewick提出的(1, 5, 19, 41, 109,…)，该序列的项来自 ${\displaystyle 9\times 4^{i}-9\times 2^{i}+1}$和 ${\displaystyle 2^{i+2}\times (2^{i+2}-3)+1}$ 这两个算式。这项研究也表明“比较在希尔排序中是最主要的操作，而不是交换。”用这样步长序列的希尔排序比插入排序要快，甚至在小数组中比快速排序和堆排序还快，但是在涉及大量数据时希尔排序还是比快速排序慢。</p><p>&emsp;&emsp;另一个在大数组中表现优异的步长序列是（斐波那契数列除去0和1将剩余的数以黄金分区比的两倍的幂进行运算得到的数列）：(1, 9, 34, 182, 836, 4025, 19001, 90358, 428481, 2034035, 9651787, 45806244, 217378076, 1031612713,…)</p><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://marslisiyuan.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="https://marslisiyuan.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="希尔排序" scheme="https://marslisiyuan.github.io/tags/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法系列之一：八大排序之插入排序</title>
    <link href="https://marslisiyuan.github.io/2018/01/01/DS/"/>
    <id>https://marslisiyuan.github.io/2018/01/01/DS/</id>
    <published>2017-12-31T16:00:00.000Z</published>
    <updated>2018-08-01T09:22:30.338Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>个人博客：<a href="https://wordzzzz.github.io/" target="_blank" rel="noopener">https://wordzzzz.github.io/</a> &amp;&amp; <a href="https://wordzzzz.gitee.io/" target="_blank" rel="noopener">https://wordzzzz.gitee.io/</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/DS-A" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/DS-A</a></strong></li><li><strong>博客作者：WordZzzz，一只热爱技术的文艺青年</strong></li></ul><hr><p>[toc]</p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;建议先看排序综述，传送门：<a href="http://blog.csdn.net/u011475210/article/details/79014021" target="_blank" rel="noopener">数据结构与算法系列之一：八大排序综述</a>。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>&emsp;&emsp;插入排序（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到 ${\displaystyle O(1)}$ 的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>&emsp;&emsp;一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p><ul><li>从第一个元素开始，该元素可以认为已经被排序。</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描。</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置。</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置。</li><li>将新元素插入到该位置后。</li><li>重复步骤2~5。</li></ul><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>&emsp;&emsp;wikipedia的大数据规模演示：</p><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180108102156155?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="insertsort from wikipedia"></div><br><p></p><p>&emsp;&emsp;wordzzzz的小数据规模演示：</p><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20180108102249736?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="insertsortfrom wordzzzz"></div><br><p></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 插入排序</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">throw</span> invalid_argument(<span class="string">"Array must not be empty"</span>); </span><br><span class="line"><span class="keyword">if</span> (length &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; ++i)&#123;<span class="comment">//外循环，一次插入一个数据</span></span><br><span class="line">T tmp = <span class="built_in">array</span>[i]; </span><br><span class="line"><span class="keyword">int</span> j = i - <span class="number">1</span>;<span class="comment">//内循环，从i-1开始</span></span><br><span class="line"><span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; <span class="built_in">array</span>[j] &gt; tmp)&#123;</span><br><span class="line"><span class="built_in">array</span>[j+<span class="number">1</span>] = <span class="built_in">array</span>[j]; </span><br><span class="line">--j; </span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">array</span>[j+<span class="number">1</span>] = tmp; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><ul><li>数据结构    数组</li><li>最坏时间复杂度    ${\displaystyle O(n^{2})}$</li><li>最优时间复杂度    ${\displaystyle O(n)}$</li><li>平均时间复杂度    ${\displaystyle O(n^{2})}$</li><li>空间复杂度    总共 ${\displaystyle O(n)}$，需要辅助空间 ${\displaystyle O(1)}$</li></ul><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>&emsp;&emsp;如果比较操作的代价比交换操作大的话，可以采用二分查找法来减少比较操作的数目。该算法可以认为是插入排序的一个变种，称为二分查找插入排序。</p><p>&emsp;&emsp;如果目标是把n个元素的序列升序排列，那么采用插入排序存在最好情况和最坏情况。最好情况就是，序列已经是升序排列了，在这种情况下，需要进行的比较操作需 ${\displaystyle n-1}$ 次即可。最坏情况就是，序列是降序排列，那么此时需要进行的比较共有 ${\displaystyle {\frac {1}{2}}n(n-1)}$ 次。插入排序的赋值操作是比较操作的次数减去 ${\displaystyle n-1}$ 次，（因为 ${\displaystyle n-1}$ 次循环中，每一次循环的比较都比赋值多一个，多在最后那一次比较并不带来赋值）。平均来说插入排序算法复杂度为 ${\displaystyle O(n^{2})}$ 。因而，插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，例如，量级小于千；或者若已知输入元素大致上按照顺序排列，那么插入排序还是一个不错的选择。 插入排序在工业级库中也有着广泛的应用，在STL的sort算法和stdlib的qsort算法中，都将插入排序作为快速排序的补充，用于少量元素的排序（通常为8个或以下）。</p><p>&emsp;&emsp;下一篇将介绍插入排序的升级版：希尔排序。</p><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://marslisiyuan.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="https://marslisiyuan.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="插入排序" scheme="https://marslisiyuan.github.io/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>《剑指offer》刷题笔记（举例让抽象具体化）：二叉树中和为某一值的路径</title>
    <link href="https://marslisiyuan.github.io/2017/12/01/offer-26/"/>
    <id>https://marslisiyuan.github.io/2017/12/01/offer-26/</id>
    <published>2017-11-30T16:00:00.000Z</published>
    <updated>2018-08-01T09:22:30.329Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li><li><strong>题&emsp;&emsp;库：剑指offer</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>当一眼看不出问题中隐藏的规律时，我们可以试着用一两个具体的例子模拟操作的过程，说不定这样那就能通过具体的例子找到抽象的规律。</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>还是深度优先搜索，这次我们用前序遍历，就是先对root做一些该有的处理，再遍历左右子树。这里我们用到两个全局变量，result来存放最终结果，tmp用来存放临时结果。</p><p>每次遍历，我们先把root的值压入tmp，然后判断现有root是否同时满足：</p><ul><li>与给定数值相减为0；</li><li>左子树为空；</li><li>右子树为空。</li></ul><p>如果满足条件，就将tmp压入result中，否则，依次遍历左右子树。需要注意的是，遍历左右子树的时候，全局变量tmp是不清空的，直到到了根结点才请空tmp。</p><h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">int val;</span></span><br><span class="line"><span class="comment">struct TreeNode *left;</span></span><br><span class="line"><span class="comment">struct TreeNode *right;</span></span><br><span class="line"><span class="comment">TreeNode(int x) :</span></span><br><span class="line"><span class="comment">val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; FindPath(TreeNode* root,<span class="keyword">int</span> expectNumber) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        tmp.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>((expectNumber - root-&gt;val) == <span class="number">0</span> &amp;&amp; root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">            result.push_back(tmp);</span><br><span class="line">        FindPath(root-&gt;left, expectNumber-root-&gt;val);</span><br><span class="line">        FindPath(root-&gt;right, expectNumber-root-&gt;val);</span><br><span class="line">        tmp.pop_back();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Python版代码实现"><a href="#Python版代码实现" class="headerlink" title="Python版代码实现"></a>Python版代码实现</h2><h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回二维列表，内部每个列表表示找到的路径</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindPath</span><span class="params">(self, root, expectNumber)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">and</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right <span class="keyword">and</span> root.val == expectNumber:</span><br><span class="line">            <span class="keyword">return</span> [[root.val]]</span><br><span class="line">        res = []</span><br><span class="line">        left = self.FindPath(root.left, expectNumber-root.val)</span><br><span class="line">        right = self.FindPath(root.right, expectNumber-root.val)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> left+right:</span><br><span class="line">            res.append([root.val]+i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="AtOffer" scheme="https://marslisiyuan.github.io/categories/AtOffer/"/>
    
    
      <category term="AtOffer" scheme="https://marslisiyuan.github.io/tags/AtOffer/"/>
    
      <category term="c++" scheme="https://marslisiyuan.github.io/tags/c/"/>
    
      <category term="举例让抽象具体化" scheme="https://marslisiyuan.github.io/tags/%E4%B8%BE%E4%BE%8B%E8%AE%A9%E6%8A%BD%E8%B1%A1%E5%85%B7%E4%BD%93%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>《剑指offer》刷题笔记（代码完整性）：数值的整数次方</title>
    <link href="https://marslisiyuan.github.io/2017/12/01/offer-9/"/>
    <id>https://marslisiyuan.github.io/2017/12/01/offer-9/</id>
    <published>2017-11-30T16:00:00.000Z</published>
    <updated>2018-08-01T09:22:30.338Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/CodingInterviewChinese2" target="_blank" rel="noopener">https://github.com/WordZzzz/CodingInterviewChinese2</a></strong></li><li><strong>文章地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li><li><strong>题&emsp;&emsp;库：剑指offer</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>代码的规范性：书写清晰，布局清晰，命名合理。<br>代码的完整性：功能测试，边界测试，负面测试。</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>方法一：公式求解</p><p>我们知道当指数为负数的时候，可以先对指针求绝对值，然后算出次方的结果之后再取倒数。如果要自己实现，那么就需要考虑各种错误处理和边界问题。比如，既然有求倒数，对0求倒数怎么办，当底数是0且指数是负数的时候，如果不做特殊处理，就会出现对0求倒数而导致程序运行出错。</p><p>一个细节值得我们注意：在判断底数是不是等于0时，不能直接写base == 0，这是因为在计算机内表示小数时都有误差。判断两个小数是否相等，只能判断他们之差的绝对值是不是在一个很小的范围内。如果两个数差值很小，就可以认为它们相等。这就是我们定义函数equal的原因。</p><p>方法二：迭代</p><p><code>!$a^n = \begin{cases} a^{n/2}*a^{n/2}, &amp; \text{n为偶数} \\ a^{(n-1)/2}*a^{(n-1)/2}*a, &amp; \text{n为奇数} \end{cases} $</code></p><p>这个公式很容易就用递归来实现。</p><h2 id="C-版代码实现："><a href="#C-版代码实现：" class="headerlink" title="C++版代码实现："></a>C++版代码实现：</h2><h3 id="调用pow："><a href="#调用pow：" class="headerlink" title="调用pow："></a>调用pow：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> result;</span><br><span class="line">        <span class="keyword">if</span>(exponent &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            result = <span class="built_in">pow</span>(base, exponent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            result = <span class="built_in">pow</span>(base, -exponent);</span><br><span class="line">            result = <span class="number">1</span> / result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="不调用pow："><a href="#不调用pow：" class="headerlink" title="不调用pow："></a>不调用pow：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool g_InvalidInput = false;</span><br><span class="line">    </span><br><span class="line">    double Power(double base, int exponent) &#123;</span><br><span class="line">        g_InvalidInput = false;</span><br><span class="line">        </span><br><span class="line">        if(equal(base, 0.0) &amp;&amp; exponent &lt; 0) &#123;</span><br><span class="line">            g_InvalidInput = true;</span><br><span class="line">            return 0.0;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        unsigned int absExponent = (unsigned int)(exponent);</span><br><span class="line">        if(exponent &lt; 0)</span><br><span class="line">            absExponent = (unsigned int)(-exponent);</span><br><span class="line">        </span><br><span class="line">        double result = PowerWithUnsignedExponent(base, absExponent);</span><br><span class="line">        if(exponent &lt; 0)</span><br><span class="line">            result = 1.0 / result;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    double PowerWithUnsignedExponent(double base, unsigned int exponent)&#123;</span><br><span class="line">        double result = 1.0;</span><br><span class="line">        for (int i = 1; i &lt;= exponent; ++i)</span><br><span class="line">            result *= base;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool equal(double num1, double num2)&#123;</span><br><span class="line">        if((num1 - num2 &gt; -0.0000001) &amp;&amp; (num1 - num2 &lt; 0.0000001))</span><br><span class="line">            return true;</span><br><span class="line">        else</span><br><span class="line">            return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="递归："><a href="#递归：" class="headerlink" title="递归："></a>递归：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> g_InvalidInput = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        g_InvalidInput = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(equal(base, <span class="number">0.0</span>) &amp;&amp; exponent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            g_InvalidInput = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> absExponent = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(exponent);</span><br><span class="line">        <span class="keyword">if</span>(exponent &lt; <span class="number">0</span>)</span><br><span class="line">            absExponent = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(-exponent);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">double</span> result = PowerWithUnsignedExponent(base, absExponent);</span><br><span class="line">        <span class="keyword">if</span>(exponent &lt; <span class="number">0</span>)</span><br><span class="line">            result = <span class="number">1.0</span> / result;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">PowerWithUnsignedExponent</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">unsigned</span> <span class="keyword">int</span> exponent)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(exponent == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(exponent == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> base;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">double</span> result = PowerWithUnsignedExponent(base, exponent &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        result *= result;</span><br><span class="line">        <span class="keyword">if</span>(exponent &amp; <span class="number">0x1</span> == <span class="number">1</span>)</span><br><span class="line">            result *= base;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">equal</span><span class="params">(<span class="keyword">double</span> num1, <span class="keyword">double</span> num2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((num1 - num2 &gt; <span class="number">-0.0000001</span>) &amp;&amp; (num1 - num2 &lt; <span class="number">0.0000001</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Python-代码实现："><a href="#Python-代码实现：" class="headerlink" title="Python 代码实现："></a>Python 代码实现：</h2><h3 id="调用pow：-1"><a href="#调用pow：-1" class="headerlink" title="调用pow："></a>调用pow：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Power</span><span class="params">(self, base, exponent)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> exponent &gt;= <span class="number">0</span>:</span><br><span class="line">            result = pow(base, exponent)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result = pow(base, -exponent)</span><br><span class="line">            result = <span class="number">1</span> / result</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h3 id="不调用pow"><a href="#不调用pow" class="headerlink" title="不调用pow"></a>不调用pow</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">class Solution:</span><br><span class="line">    def Power(self, base, exponent):</span><br><span class="line">        # write code here</span><br><span class="line">        flag = 0</span><br><span class="line">        if base == 0:</span><br><span class="line">            return False</span><br><span class="line">        if exponent == 0:</span><br><span class="line">            return 1</span><br><span class="line">        if exponent &lt; 0:</span><br><span class="line">            flag = 1</span><br><span class="line">        result = 1</span><br><span class="line">        for i in range(abs(exponent)):</span><br><span class="line">            result *= base</span><br><span class="line">        if flag == 1:</span><br><span class="line">            result = 1 / result</span><br><span class="line">        return result</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="AtOffer" scheme="https://marslisiyuan.github.io/categories/AtOffer/"/>
    
    
      <category term="AtOffer" scheme="https://marslisiyuan.github.io/tags/AtOffer/"/>
    
      <category term="c++" scheme="https://marslisiyuan.github.io/tags/c/"/>
    
      <category term="代码完整性" scheme="https://marslisiyuan.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%8C%E6%95%B4%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>《剑指offer》刷题笔记（代码完整性）：打印1到最大的n位数</title>
    <link href="https://marslisiyuan.github.io/2017/12/01/offer-8/"/>
    <id>https://marslisiyuan.github.io/2017/12/01/offer-8/</id>
    <published>2017-11-30T16:00:00.000Z</published>
    <updated>2018-08-01T09:22:30.338Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/CodingInterviewChinese2" target="_blank" rel="noopener">https://github.com/WordZzzz/CodingInterviewChinese2</a></strong></li><li><strong>文章地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li><li><strong>题&emsp;&emsp;库：剑指offer</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这道题牛客网上没有，但是剑指offer上有，看完之后觉得挺有用的，所以我还是整理一下吧。</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入数字n，按顺序打印出从1到最大的n位十进制数。比如输入3，则打印出1、2、3一直到最大的3位数即999。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>没有规定n的范围，所以我们需要考虑大数的问题。</p><p>方法一：字符串模拟</p><p>用字符串表示数字的时候，最直观的方法就是字符串里每个字符都是‘0’到‘9’之间的某一个字符，用来表示数字中的一位。因为数字最大是n位，所以我们需要一个长度为n+1的字符串（字符串结尾符号‘\0’，这个我记得之前强调过了）。当实际数字不够n位的时候在字符串前半部分补0，打印的时候不打印前半部分的0就好。同时我们用进位标志位作为循环终止条件。</p><p>方法二：递归</p><p>如果我们在数字前面补0的话，就会发现n位所有十进制数其实就是n个从0到9的全排列。也就是说，我们把数字的每一位都从0到9排列一遍，就得到所有的十进制数，只是我们在打印的时候，数字排在前面的0我们不打印出来罢了。</p><h2 id="C-版代码实现："><a href="#C-版代码实现：" class="headerlink" title="C++版代码实现："></a>C++版代码实现：</h2><h3 id="字符串模拟："><a href="#字符串模拟：" class="headerlink" title="字符串模拟："></a>字符串模拟：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ====================方法一====================</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print1ToMaxOfNDigits_1</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *number = <span class="keyword">new</span> <span class="keyword">char</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(number, <span class="string">'0'</span>, n);</span><br><span class="line">    number[n] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!Increment(number))</span><br><span class="line">    &#123;</span><br><span class="line">        PrintNumber(number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[]number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串number表示一个数字，在 number上增加1</span></span><br><span class="line"><span class="comment">// 如果做加法溢出，则返回true；否则为false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Increment</span><span class="params">(<span class="keyword">char</span>* number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> isOverflow = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> nTakeOver = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> nLength = <span class="built_in">strlen</span>(number);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nLength - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> nSum = number[i] - <span class="string">'0'</span> + nTakeOver;</span><br><span class="line">        <span class="keyword">if</span> (i == nLength - <span class="number">1</span>)</span><br><span class="line">            nSum++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nSum &gt;= <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                isOverflow = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                nSum -= <span class="number">10</span>;</span><br><span class="line">                nTakeOver = <span class="number">1</span>;</span><br><span class="line">                number[i] = <span class="string">'0'</span> + nSum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            number[i] = <span class="string">'0'</span> + nSum;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isOverflow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================公共函数====================</span></span><br><span class="line"><span class="comment">// 字符串number表示一个数字，数字有若干个0开头</span></span><br><span class="line"><span class="comment">// 打印出这个数字，并忽略开头的0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintNumber</span><span class="params">(<span class="keyword">char</span>* number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> isBeginning0 = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> nLength = <span class="built_in">strlen</span>(number);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nLength; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isBeginning0 &amp;&amp; number[i] != <span class="string">'0'</span>)</span><br><span class="line">            isBeginning0 = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isBeginning0)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>, number[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归："><a href="#递归：" class="headerlink" title="递归："></a>递归：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ====================方法二====================</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print1ToMaxOfNDigits_2</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* number = <span class="keyword">new</span> <span class="keyword">char</span>[n + <span class="number">1</span>];</span><br><span class="line">    number[n] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        number[<span class="number">0</span>] = i + <span class="string">'0'</span>;</span><br><span class="line">        Print1ToMaxOfNDigitsRecursively(number, n, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print1ToMaxOfNDigitsRecursively</span><span class="params">(<span class="keyword">char</span>* number, <span class="keyword">int</span> length, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == length - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PrintNumber(number);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        number[index + <span class="number">1</span>] = i + <span class="string">'0'</span>;</span><br><span class="line">        Print1ToMaxOfNDigitsRecursively(number, length, index + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================公共函数====================</span></span><br><span class="line"><span class="comment">// 字符串number表示一个数字，数字有若干个0开头</span></span><br><span class="line"><span class="comment">// 打印出这个数字，并忽略开头的0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintNumber</span><span class="params">(<span class="keyword">char</span>* number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> isBeginning0 = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> nLength = <span class="built_in">strlen</span>(number);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nLength; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isBeginning0 &amp;&amp; number[i] != <span class="string">'0'</span>)</span><br><span class="line">            isBeginning0 = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isBeginning0)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>, number[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="AtOffer" scheme="https://marslisiyuan.github.io/categories/AtOffer/"/>
    
    
      <category term="AtOffer" scheme="https://marslisiyuan.github.io/tags/AtOffer/"/>
    
      <category term="c++" scheme="https://marslisiyuan.github.io/tags/c/"/>
    
      <category term="代码完整性" scheme="https://marslisiyuan.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%8C%E6%95%B4%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>《剑指offer》刷题笔记（代码的鲁棒性）：树的子结构</title>
    <link href="https://marslisiyuan.github.io/2017/12/01/offer-7/"/>
    <id>https://marslisiyuan.github.io/2017/12/01/offer-7/</id>
    <published>2017-11-30T16:00:00.000Z</published>
    <updated>2018-08-01T09:22:30.338Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/CodingInterviewChinese2" target="_blank" rel="noopener">https://github.com/WordZzzz/CodingInterviewChinese2</a></strong></li><li><strong>文章地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li><li><strong>题&emsp;&emsp;库：剑指offer</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前在leetcode刷题的时候，感觉做的最多的就是树这块了。</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>第一步在树A中查找与根结点的值一样的结点，这实际上就是树的遍历。所以，递归和循环都可以。</p><p>第二步是判断树A中以R为根结点的子树是不是和树B有相同的结构。同样的，递归和循环都可以。</p><h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">int val;</span></span><br><span class="line"><span class="comment">struct TreeNode *left;</span></span><br><span class="line"><span class="comment">struct TreeNode *right;</span></span><br><span class="line"><span class="comment">TreeNode(int x) :</span></span><br><span class="line"><span class="comment">val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">HasSubtree</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot1 == <span class="literal">NULL</span> || pRoot2 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(pRoot1, pRoot2) || HasSubtree(pRoot1-&gt;left, pRoot2) || HasSubtree(pRoot1-&gt;right, pRoot2);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot2 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(pRoot1 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> pRoot1-&gt;val == pRoot2-&gt;val &amp;&amp; dfs(pRoot1-&gt;left, pRoot2-&gt;left) &amp;&amp; dfs(pRoot1-&gt;right, pRoot2-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h2><h3 id="DFS-1"><a href="#DFS-1" class="headerlink" title="DFS"></a>DFS</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">HasSubtree</span><span class="params">(self, pRoot1, pRoot2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot1 <span class="keyword">or</span> <span class="keyword">not</span> pRoot2:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> self.dfs(pRoot1, pRoot2) <span class="keyword">or</span> self.HasSubtree(pRoot1.left, pRoot2) <span class="keyword">or</span> self.HasSubtree(pRoot1.right, pRoot2)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, pRoot1, pRoot2)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot2:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot1:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> pRoot1.val == pRoot2.val <span class="keyword">and</span> self.dfs(pRoot1.left, pRoot2.left) <span class="keyword">and</span> self.dfs(pRoot1.right, pRoot2.right)</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="AtOffer" scheme="https://marslisiyuan.github.io/categories/AtOffer/"/>
    
    
      <category term="AtOffer" scheme="https://marslisiyuan.github.io/tags/AtOffer/"/>
    
      <category term="c++" scheme="https://marslisiyuan.github.io/tags/c/"/>
    
      <category term="代码的鲁棒性" scheme="https://marslisiyuan.github.io/tags/%E4%BB%A3%E7%A0%81%E7%9A%84%E9%B2%81%E6%A3%92%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>《剑指offer》刷题笔记（综合）：树中两个结点的最低公共祖先</title>
    <link href="https://marslisiyuan.github.io/2017/12/01/offer-69/"/>
    <id>https://marslisiyuan.github.io/2017/12/01/offer-69/</id>
    <published>2017-11-30T16:00:00.000Z</published>
    <updated>2018-08-01T09:22:30.337Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li><li><strong>题&emsp;&emsp;库：剑指offer</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个树节点，求他们的最低公共祖先。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>求树中两个节点的最低公共祖先，不能说只是一个题目，而应该说是一组题目。不同条件下的题目解法是完全不一样的，比如，是否是二叉树、二叉排序树；如果不是二叉树，是否有指向父节点的指针（是的话可以转换成求两个链表的第一个公共节点，不是的话可以转换成求两个链表的最后一个公共节点）。</p><p>下面的代码针对的是普通树，并且没有指向父节点的指针，所以我们转换成求两个链表的最后一个公共节点。代码中GetNodePath用来得到根节点pRoot开始到达节点pNode的路径，这条路径保存在path中，函数GetLastCommonNode用来得到两个路径path1和path2的最后一个公共节点。函数GetLastCommonParent先调用GetNodePath得到pRoot到达pNode1的路径path1，再得到pRoot到达pNode2的路径path2，接着调用GetLastCommonNode得到path1和path2的最后一个公共节点，即我们要找的最低公共祖先。</p><h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetNodePath</span><span class="params">(<span class="keyword">const</span> TreeNode* pRoot, <span class="keyword">const</span> TreeNode* pNode, <span class="built_in">list</span>&lt;<span class="keyword">const</span> TreeNode*&gt;&amp; path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot == pNode)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">    path.push_back(pRoot);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt;::const_iterator i = pRoot-&gt;m_vChildren.begin();</span><br><span class="line">    <span class="keyword">while</span>(!found &amp;&amp; i &lt; pRoot-&gt;m_vChildren.end())</span><br><span class="line">    &#123;</span><br><span class="line">        found = GetNodePath(*i, pNode, path);</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(!found)</span><br><span class="line">        path.pop_back();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TreeNode* GetLastCommonNode</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">list</span>&lt;<span class="keyword">const</span> TreeNode*&gt;&amp; path1, </span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">list</span>&lt;<span class="keyword">const</span> TreeNode*&gt;&amp; path2</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">const</span> TreeNode*&gt;::const_iterator iterator1 = path1.begin();</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">const</span> TreeNode*&gt;::const_iterator iterator2 = path2.begin();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> TreeNode* pLast = <span class="literal">nullptr</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>(iterator1 != path1.end() &amp;&amp; iterator2 != path2.end())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*iterator1 == *iterator2)</span><br><span class="line">            pLast = *iterator1;</span><br><span class="line"> </span><br><span class="line">        iterator1++;</span><br><span class="line">        iterator2++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> pLast;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> TreeNode* <span class="title">GetLastCommonParent</span><span class="params">(<span class="keyword">const</span> TreeNode* pRoot, <span class="keyword">const</span> TreeNode* pNode1, <span class="keyword">const</span> TreeNode* pNode2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot == <span class="literal">nullptr</span> || pNode1 == <span class="literal">nullptr</span> || pNode2 == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">const</span> TreeNode*&gt; path1;</span><br><span class="line">    GetNodePath(pRoot, pNode1, path1);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">const</span> TreeNode*&gt; path2;</span><br><span class="line">    GetNodePath(pRoot, pNode2, path2);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> GetLastCommonNode(path1, path2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="AtOffer" scheme="https://marslisiyuan.github.io/categories/AtOffer/"/>
    
    
      <category term="AtOffer" scheme="https://marslisiyuan.github.io/tags/AtOffer/"/>
    
      <category term="c++" scheme="https://marslisiyuan.github.io/tags/c/"/>
    
      <category term="综合" scheme="https://marslisiyuan.github.io/tags/%E7%BB%BC%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>《剑指offer》刷题笔记（综合）：把字符串转换成整数</title>
    <link href="https://marslisiyuan.github.io/2017/12/01/offer-68/"/>
    <id>https://marslisiyuan.github.io/2017/12/01/offer-68/</id>
    <published>2017-11-30T16:00:00.000Z</published>
    <updated>2018-08-01T09:22:30.337Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li><li><strong>题&emsp;&emsp;库：剑指offer</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><p>输入一个字符串,包括数字字母符号,可以为空</p><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><p>如果是合法的数值表达则返回该数字，否则返回0</p><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p>输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+2147483647</span><br><span class="line">    1a33</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2147483647</span><br><span class="line">    0</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>题目虽然简单，但是要写出完整的代码也是需要经过全面的思考才可以。</p><p>给出一个题目，我们首先要考虑的就是边界问题。对于这个题目，边界问题有：</p><ul><li>空指针；</li><li>空字符串””；</li><li>带有正负号；</li><li>只有正负号；</li><li>上下溢出；</li><li>错误标志输出。</li></ul><p>代码中用两个函数来实现该功能，其中标志位g_nStatus用来表示是否为异常输出，标志位用来表示是否为负数。需要注意的也就只有上面提到的边界问题。具体实现如下。</p><h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> Status &#123;kValid = <span class="number">0</span>, kInvalid&#125;;</span><br><span class="line">    <span class="keyword">int</span> g_nStatus = kValid;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        g_nStatus = kInvalid;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* cstr = str.c_str();</span><br><span class="line">        <span class="comment">//判断是否为空指针和是否为空字符串</span></span><br><span class="line">        <span class="keyword">if</span>(cstr != <span class="literal">NULL</span> &amp;&amp; *cstr != <span class="string">'\0'</span>)&#123;</span><br><span class="line">            <span class="keyword">bool</span> minus = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//正负号区分</span></span><br><span class="line">            <span class="keyword">if</span>(*cstr == <span class="string">'+'</span>)</span><br><span class="line">                cstr++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(*cstr == <span class="string">'-'</span>)&#123;</span><br><span class="line">                cstr++;</span><br><span class="line">                minus = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果不是只有正负号，就进入下一个函数</span></span><br><span class="line">            <span class="keyword">if</span>(*cstr != <span class="string">'\0'</span>)</span><br><span class="line">                num = StrToIntCore(cstr, minus);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)num;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">StrToIntCore</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* cstr, <span class="keyword">bool</span> minus)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(*cstr != <span class="string">'\0'</span>)&#123;</span><br><span class="line">            <span class="comment">//判断是否为非法值</span></span><br><span class="line">            <span class="keyword">if</span>(*cstr &gt;= <span class="string">'0'</span> &amp;&amp; *cstr &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> flag = minus ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">                num = num * <span class="number">10</span> + flag * (*cstr - <span class="string">'0'</span>);</span><br><span class="line">                <span class="comment">//判断是否溢出</span></span><br><span class="line">                <span class="keyword">if</span>((!minus &amp;&amp; num &gt; <span class="number">0x7fffffff</span>) || (minus &amp;&amp; num &lt; (<span class="keyword">signed</span> <span class="keyword">int</span>)<span class="number">0x80000000</span>))&#123;</span><br><span class="line">                    num = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cstr++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        #判断是否正常结束</span><br><span class="line">        <span class="keyword">if</span>(*cstr == <span class="string">'\0'</span>)</span><br><span class="line">            g_nStatus = kValid;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="AtOffer" scheme="https://marslisiyuan.github.io/categories/AtOffer/"/>
    
    
      <category term="AtOffer" scheme="https://marslisiyuan.github.io/tags/AtOffer/"/>
    
      <category term="c++" scheme="https://marslisiyuan.github.io/tags/c/"/>
    
      <category term="综合" scheme="https://marslisiyuan.github.io/tags/%E7%BB%BC%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>《剑指offer》刷题笔记（字符串）：字符流中第一个不重复的字符</title>
    <link href="https://marslisiyuan.github.io/2017/12/01/offer-67/"/>
    <id>https://marslisiyuan.github.io/2017/12/01/offer-67/</id>
    <published>2017-11-30T16:00:00.000Z</published>
    <updated>2018-08-01T09:22:30.337Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li><li><strong>题&emsp;&emsp;库：剑指offer</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。</p><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h2><p>如果当前字符流没有存在出现一次的字符，返回#字符。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>好吧，我是第一次见这种需要写部分测试函数的题目。</p><p>题目很简单，用hash表来实现，其实hash表的键值为输入字符的ASCII码，hash的值初始化为-1，出现一次则设置为该字符在字符串中的位置，出现两次以上则设置为-2。</p><p>最后搜索的时候，根据hash表的值就可以找到第一个不重复的字符。</p><ul><li>occurrence[i] = -1: 这个字符不存在；</li><li>occurrence[i] = -2: 这个字符出现了多次；</li><li>occurrence[i] &gt;= 0: 这个字符只出现一次。</li></ul><p>需要注意的是，因为我们要求如果当前字符流没有存在出现一次的字符，返回#字符，所以我们初始化字符时应该设置为’#’而不是’\0’。</p><h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Solution()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(occurrence, <span class="number">-1</span>, <span class="keyword">sizeof</span>(occurrence));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Insert one char from stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(occurrence[ch] == <span class="number">-1</span>)</span><br><span class="line">            occurrence[ch] = index;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(occurrence[ch] &gt;= <span class="number">0</span>)</span><br><span class="line">            occurrence[ch] = <span class="number">-2</span>;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//return the first appearence once char in current stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch = <span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">int</span> minIndex = numeric_limits&lt;<span class="keyword">int</span>&gt;::max();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(occurrence[i] &gt;= <span class="number">0</span> &amp;&amp; occurrence[i] &lt;= minIndex)&#123;</span><br><span class="line">                ch = (<span class="keyword">char</span>)i;</span><br><span class="line">                minIndex = occurrence[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ch;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> occurrence[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="AtOffer" scheme="https://marslisiyuan.github.io/categories/AtOffer/"/>
    
    
      <category term="AtOffer" scheme="https://marslisiyuan.github.io/tags/AtOffer/"/>
    
      <category term="c++" scheme="https://marslisiyuan.github.io/tags/c/"/>
    
      <category term="字符串" scheme="https://marslisiyuan.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>《剑指offer》刷题笔记（字符串）：正则表达式匹配</title>
    <link href="https://marslisiyuan.github.io/2017/12/01/offer-66/"/>
    <id>https://marslisiyuan.github.io/2017/12/01/offer-66/</id>
    <published>2017-11-30T16:00:00.000Z</published>
    <updated>2018-08-01T09:22:30.337Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li><li><strong>题&emsp;&emsp;库：剑指offer</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数用来匹配包括’.’和’*‘的正则表达式。模式中的字符’.’表示任意一个字符，而’*‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab*ac*a”匹配，但是与”aa.a”和”ab*a”均不匹配。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>只有当模式串和字符串同时等于’\0’，才可以认为两个串匹配。</p><p>在匹配中，对于每个位的匹配可以分为三种情况:</p><ul><li>1、（相应位匹配||模式串为’.’&amp;&amp;字符串不是’\0’）&amp;&amp;模式串下一位是’*’</li><li>2、（相应位匹配||模式串为’.’&amp;&amp;字符串不是’\0’）&amp;&amp;模式串下一位不是’*’</li><li>3、相应位不匹配&amp;&amp;（模式位不为’.’||字符串是’\0’）</li></ul><p>对应1，最复杂。分为*取0，*取1，*&gt;=2三种情况。<br>*取0对应跳过当前匹配位，继续寻找patter的下一个匹配位，str不变，pattern+2<br>*取1对应当前匹配位算一次成功匹配，str+1，pattern+2<br>*取&gt;=2对应一次成功匹配，继续匹配字符串的下一位是否匹配，str+1，pattern不变<br>三者取或。即只要有一种情况能匹配成功认为字符串就是匹配成功的。<br>对应2，相当于一次成功匹配，str+1，pattern+1<br>对应3，匹配失败，直接返回false</p><h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">const</span> <span class="keyword">char</span>* pattern)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="literal">nullptr</span> || pattern == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> matchCore(str, pattern);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">matchCore</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">const</span> <span class="keyword">char</span>* pattern)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(*str == <span class="string">'\0'</span> &amp;&amp; *pattern == <span class="string">'\0'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span>(*str != <span class="string">'\0'</span> &amp;&amp; *pattern == <span class="string">'\0'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span>(*(pattern + <span class="number">1</span>) == <span class="string">'*'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(*pattern == *str || (*pattern == <span class="string">'.'</span> &amp;&amp; *str != <span class="string">'\0'</span>))</span><br><span class="line">                <span class="comment">// 进入有限状态机的下一个状态</span></span><br><span class="line">                <span class="keyword">return</span> matchCore(str + <span class="number">1</span>, pattern + <span class="number">2</span>)</span><br><span class="line">                <span class="comment">// 继续留在有限状态机的当前状态 </span></span><br><span class="line">                || matchCore(str + <span class="number">1</span>, pattern)</span><br><span class="line">                <span class="comment">// 略过一个'*' </span></span><br><span class="line">                || matchCore(str, pattern + <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 略过一个'*'</span></span><br><span class="line">                <span class="keyword">return</span> matchCore(str, pattern + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span>(*str == *pattern || (*pattern == <span class="string">'.'</span> &amp;&amp; *str != <span class="string">'\0'</span>))</span><br><span class="line">            <span class="keyword">return</span> matchCore(str + <span class="number">1</span>, pattern + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="AtOffer" scheme="https://marslisiyuan.github.io/categories/AtOffer/"/>
    
    
      <category term="AtOffer" scheme="https://marslisiyuan.github.io/tags/AtOffer/"/>
    
      <category term="c++" scheme="https://marslisiyuan.github.io/tags/c/"/>
    
      <category term="字符串" scheme="https://marslisiyuan.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>《剑指offer》刷题笔记（字符串）：替换空格</title>
    <link href="https://marslisiyuan.github.io/2017/12/01/offer-65/"/>
    <id>https://marslisiyuan.github.io/2017/12/01/offer-65/</id>
    <published>2017-11-30T16:00:00.000Z</published>
    <updated>2018-08-01T09:22:30.337Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/CodingInterviewChinese2" target="_blank" rel="noopener">https://github.com/WordZzzz/CodingInterviewChinese2</a></strong></li><li><strong>文章地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li><li><strong>题&emsp;&emsp;库：剑指offer</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>[toc]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>C/C++中每个字符串都以字符‘\0’作为结尾，这样我们就能很方便地找到字符串的最后尾部。但是由于这个特点，每个字符串中都有一个额外字符的开销，稍不留神就会造成字符串的越界。</p><p>为了节省内存，C/C++把常量字符串放到单独的一个内存区域。当几个指针赋值给相同的常量字符串时，他们实际上会指向相同的内存地址，在下面的代码中，str1 == str2成立，因为它们指向同一地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* str1 = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="keyword">char</span>* str2 = <span class="string">"hello world"</span>;</span><br></pre></td></tr></table></figure><p>但用常量内存初始化数组，情况就不同了，在下面的代码中，str3 == str4不成立，因为这是两个字符串数组，会为它们分配两个长度为12个字节的空间，他们的初始地址是不同的，所以str3和str4的值也不相同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str3[] = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="keyword">char</span> str4[] = <span class="string">"hello world"</span>;</span><br></pre></td></tr></table></figure><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="时间复杂度为O-n-2-的解法"><a href="#时间复杂度为O-n-2-的解法" class="headerlink" title="时间复杂度为O(n^2)的解法"></a>时间复杂度为O(n^2)的解法</h3><p>最直观的做法是从头到尾扫描字符串，每一个碰到空格字符的时候做替换。由于是把1个字符替换成3个字符，我们必须要把空格后面所有的字符都后移两个字节，否则就有两个字符被覆盖。</p><p>假设字符串的长度是n。对每个空格字符，需要移动后面O(n)个字符，因此对含有O(n)个空格字符的字符串而言总的时间效率是O(n^2)。</p><h3 id="时间复杂度为O-n-的解法"><a href="#时间复杂度为O-n-的解法" class="headerlink" title="时间复杂度为O(n)的解法"></a>时间复杂度为O(n)的解法</h3><p>先遍历一遍字符串，统计处空格的总数，由此计算出替换之后的字符串的总长度。然后用两个指针从字符串的后面开始复制和替换。P1指向原始字符串的末尾，而P2指向替换之后的字符串的末尾，然后向前移动P1，逐个把它指向的字符复制到P2指向的位置，直到碰到第一个空格位置。碰到第一个空格之后，把P1向前移动一格，P2之前插入字符串“%20”，同时把P2向前移动三格。具体如图所示：</p><p></p><br><div align="center"><img src="http://img.blog.csdn.net/20170925111500819?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><br><p></p><p>由于所有的字符都只复制一次，因此时间效率为O(n)。</p><h2 id="C-代码实现"><a href="#C-代码实现" class="headerlink" title="C++代码实现"></a>C++代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replaceSpace</span><span class="params">(<span class="keyword">char</span> *str,<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(str == <span class="literal">NULL</span> || length &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> originalLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> numberOfBlank = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(str[i] != <span class="string">'\0'</span>)&#123;</span><br><span class="line">            ++ originalLength;</span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">' '</span>)</span><br><span class="line">                ++ numberOfBlank;</span><br><span class="line">            ++ i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> newLength = originalLength + numberOfBlank * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(newLength &gt;= length)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> indexOfOriginal = originalLength;</span><br><span class="line">        <span class="keyword">int</span> indexOfNew = newLength;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(indexOfOriginal &gt;= <span class="number">0</span> &amp;&amp; indexOfNew &gt; indexOfOriginal)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[indexOfOriginal] == <span class="string">' '</span>)&#123;</span><br><span class="line">                str[indexOfNew--] = <span class="string">'0'</span>;</span><br><span class="line">                str[indexOfNew--] = <span class="string">'2'</span>;</span><br><span class="line">                str[indexOfNew--] = <span class="string">'%'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                str[indexOfNew--] = str[indexOfOriginal];</span><br><span class="line">            &#125;</span><br><span class="line">            -- indexOfOriginal;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Python代码实现"><a href="#Python代码实现" class="headerlink" title="Python代码实现"></a>Python代码实现</h2><h3 id="手动替换"><a href="#手动替换" class="headerlink" title="手动替换"></a>手动替换</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s 源字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> ele <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> ele.strip():</span><br><span class="line">                res += ele</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += <span class="string">'%20'</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="调用replace"><a href="#调用replace" class="headerlink" title="调用replace"></a>调用replace</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s 源字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> s.replace(<span class="string">" "</span>, <span class="string">"%20"</span>)</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="AtOffer" scheme="https://marslisiyuan.github.io/categories/AtOffer/"/>
    
    
      <category term="AtOffer" scheme="https://marslisiyuan.github.io/tags/AtOffer/"/>
    
      <category term="c++" scheme="https://marslisiyuan.github.io/tags/c/"/>
    
      <category term="字符串" scheme="https://marslisiyuan.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>《剑指offer》刷题笔记（字符串）：表示数值的字符串</title>
    <link href="https://marslisiyuan.github.io/2017/12/01/offer-64/"/>
    <id>https://marslisiyuan.github.io/2017/12/01/offer-64/</id>
    <published>2017-11-30T16:00:00.000Z</published>
    <updated>2018-08-01T09:22:30.337Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li><li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li><li><strong>题&emsp;&emsp;库：剑指offer</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>其实这道题也是正则表达式的匹配过程。判断一个字符串是否表示数值的正则表达式为：[+-]\?[0-9]*(.[0-9]*)\?([eE][+-]?[0-9]*)\?。更加详细的注释都在程序里了，这里就不再赘述。</p><h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 数字的格式可以用A[.[B]][e|EC]或者.B[e|EC]表示，其中A和C都是</span></span><br><span class="line">    <span class="comment">// 整数（可以有正负号，也可以没有），而B是一个无符号整数</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> numeric = scanInteger(&amp;str);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果出现'.'，接下来是数字的小数部分</span></span><br><span class="line">        <span class="keyword">if</span>(*str == <span class="string">'.'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++str;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 下面一行代码用||的原因：</span></span><br><span class="line">            <span class="comment">// 1. 小数可以没有整数部分，例如.123等于0.123；</span></span><br><span class="line">            <span class="comment">// 2. 小数点后面可以没有数字，例如233.等于233.0；</span></span><br><span class="line">            <span class="comment">// 3. 当然小数点前面和后面可以有数字，例如233.666</span></span><br><span class="line">            numeric = scanUnsignedInteger(&amp;str) || numeric;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果出现'e'或者'E'，接下来跟着的是数字的指数部分</span></span><br><span class="line">        <span class="keyword">if</span>(*str == <span class="string">'e'</span> || *str == <span class="string">'E'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++str;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 下面一行代码用&amp;&amp;的原因：</span></span><br><span class="line">            <span class="comment">// 1. 当e或E前面没有数字时，整个字符串不能表示数字，例如.e1、e1；</span></span><br><span class="line">            <span class="comment">// 2. 当e或E后面没有整数时，整个字符串不能表示数字，例如12e、12e+5.4</span></span><br><span class="line">            numeric = numeric &amp;&amp; scanInteger(&amp;str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> numeric &amp;&amp; *str == <span class="string">'\0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">scanUnsignedInteger</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>** str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* before = *str;</span><br><span class="line">        <span class="keyword">while</span>(**str != <span class="string">'\0'</span> &amp;&amp; **str &gt;= <span class="string">'0'</span> &amp;&amp; **str &lt;= <span class="string">'9'</span>)</span><br><span class="line">            ++(*str);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当str中存在若干0-9的数字时，返回true</span></span><br><span class="line">        <span class="keyword">return</span> *str &gt; before;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 整数的格式可以用[+|-]B表示, 其中B为无符号整数</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">scanInteger</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>** str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(**str == <span class="string">'+'</span> || **str == <span class="string">'-'</span>)</span><br><span class="line">            ++(*str);</span><br><span class="line">        <span class="keyword">return</span> scanUnsignedInteger(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="AtOffer" scheme="https://marslisiyuan.github.io/categories/AtOffer/"/>
    
    
      <category term="AtOffer" scheme="https://marslisiyuan.github.io/tags/AtOffer/"/>
    
      <category term="c++" scheme="https://marslisiyuan.github.io/tags/c/"/>
    
      <category term="字符串" scheme="https://marslisiyuan.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
</feed>
